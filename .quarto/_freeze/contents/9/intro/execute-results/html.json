{
  "hash": "d9ac60779e9b1c9481e7a72cb2565e3c",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n# R for Data Sciences\n\n\nThe main reference for this Chapter is @Wic2017.\n\n\n\n## `tibble`\n\n`tidyverse` mainly deals with `tibble` instead of `data.frame`. Therefore this is where we start.\n\n`tibble` is a `data.frame` with different attributes and requirements. The package `tibble` provides support for `tibble`. It is included in `tidyverse`. To load it, you just use the code:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n#> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.4     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.1\n#> ✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.2     \n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n\n### Create tibbles\nHere is an example of creating tibbles.\n\n::: {#exm-}\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- tibble(x=1:5, y=1, z=x^2+y)\ntbl\n#> # A tibble: 5 × 3\n#>       x     y     z\n#>   <int> <dbl> <dbl>\n#> 1     1     1     2\n#> 2     2     1     5\n#> 3     3     1    10\n#> 4     4     1    17\n#> 5     5     1    26\nattributes(tbl)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5\n#> \n#> $names\n#> [1] \"x\" \"y\" \"z\"\n```\n:::\nNote that it is more flexible to create a tibble since `tibble()` will automatically recycle inputs and allows you to refer to variables that you just created.\n:::\n\n\n::: {.callout-note}\nIn the past (for a very long time), when using `data.frame()` to create a `data.frame`, it will automatically convert strings to factors. This is changed recently that the default setting is not to convert. \n\nWhen using `tibble()` to create a `tibble`, the type of the inputs will never be changed.\n:::\n\n\n::: {.callout-note}\nIn `tibble` you may use *nonsyntactic* names as column names, which are invalid R variable names. To refer to these variables, you need to surround them with backticks `.\n\n::: {.cell}\n\n```{.r .cell-code}\ntb <- tibble(\n    `:)` = \"smile\",\n    ` ` = \"space\",\n    `2000` = \"number\"\n)\ntb\n#> # A tibble: 1 × 3\n#>   `:)`  ` `   `2000`\n#>   <chr> <chr> <chr> \n#> 1 smile space number\n```\n:::\n\n:::\n\n### Differences between tibble and data.frame.\n\n\n#### Printing\nTibbles have a refined print method that shows only the first 10 rows and all the columns that fit on screen.\n\n::: {.cell}\n\n```{.r .cell-code}\ndeck <- tibble(suit=rep(c('spades', 'hearts', 'clubs', 'diamonds'), 13), face=rep(1:13, 4))\ndeck\n#> # A tibble: 52 × 2\n#>    suit      face\n#>    <chr>    <int>\n#>  1 spades       1\n#>  2 hearts       2\n#>  3 clubs        3\n#>  4 diamonds     4\n#>  5 spades       5\n#>  6 hearts       6\n#>  7 clubs        7\n#>  8 diamonds     8\n#>  9 spades       9\n#> 10 hearts      10\n#> # ℹ 42 more rows\n```\n:::\n\n\n#### Subsetting\n\nTo get a single value, `[[]]` or `$` should be used, just like for `data.frame`. These two are almost the same. The only difference is that `[[]]` accepts positions, but `$` only accepts names.\n\nTo be used in a pipe, the special placeholder `.` will be used. \n\n::: {.cell}\n\n```{.r .cell-code}\ndeck %>% .$face\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7  8  9 10 11 12\n#> [26] 13  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7  8  9 10 11\n#> [51] 12 13\n```\n:::\nWe will talk about pipes later.\n\n\n### `%>%` symbol\n`%>%` is the pipeline symbol, which is another way to connect several functions. Most functions in tidyverse have the first argument `data`, and both the input `data` and the output are tibbles. The syntax here is that `data %>% function(arguments)` is the same as `function(data, arguments)`. The benefit is that it is easier to have many functions consecutively applied to the data. Please see the following example.\n\n::: {.cell}\n\n```{.r .cell-code}\ndata %>% function1(arguments1)\n    %>% function2(arguments2)\n    %>% function3(arguments3)\n    %>% function4(arguments4)\n\nfunction4(function3(function2(function1(data, arguments1), arguments2), arguments3), arguments4)\n\ndata2 <- function1(data, arguments1)\ndata3 <- function2(data2, arguments2)\ndata4 <- function3(data3, arguments3)\nfunction4(data4, arguments4)\n```\n:::\nThe readability of the first one is much better than the second one. Comparing to the third one, we don't need to create a lot of intermedia temporary variables.\n\n\n## Tidy Data \n\nThe same underlying data can be represented in multiple ways. The following example shows the same data organized in four different ways.\n\n\n::: {#exm-tidydatasets}\n\nThese tibbles are provided by `tidyr`. You could directly load it from `tidyverse`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndata(table1, package='tidyr')\ndata(table2, package='tidyr')\ndata(table3, package='tidyr')\ndata(table4a, package='tidyr')\ndata(table4b, package='tidyr')\n```\n:::\n\n\n1. `table1`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\n\n2. `table2`\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n#> # A tibble: 12 × 4\n#>    country      year type            count\n#>    <chr>       <dbl> <chr>           <dbl>\n#>  1 Afghanistan  1999 cases             745\n#>  2 Afghanistan  1999 population   19987071\n#>  3 Afghanistan  2000 cases            2666\n#>  4 Afghanistan  2000 population   20595360\n#>  5 Brazil       1999 cases           37737\n#>  6 Brazil       1999 population  172006362\n#>  7 Brazil       2000 cases           80488\n#>  8 Brazil       2000 population  174504898\n#>  9 China        1999 cases          212258\n#> 10 China        1999 population 1272915272\n#> 11 China        2000 cases          213766\n#> 12 China        2000 population 1280428583\n```\n:::\n\n3. `table3`\n\n::: {.cell}\n\n```{.r .cell-code}\ntable3\n#> # A tibble: 6 × 3\n#>   country      year rate             \n#>   <chr>       <dbl> <chr>            \n#> 1 Afghanistan  1999 745/19987071     \n#> 2 Afghanistan  2000 2666/20595360    \n#> 3 Brazil       1999 37737/172006362  \n#> 4 Brazil       2000 80488/174504898  \n#> 5 China        1999 212258/1272915272\n#> 6 China        2000 213766/1280428583\n```\n:::\n\n\n4. Spread across two tibbles.\n\n::: {.cell}\n\n```{.r .cell-code}\ntable4a\n#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <dbl>  <dbl>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258 213766\n\ntable4b\n#> # A tibble: 3 × 3\n#>   country         `1999`     `2000`\n#>   <chr>            <dbl>      <dbl>\n#> 1 Afghanistan   19987071   20595360\n#> 2 Brazil       172006362  174504898\n#> 3 China       1272915272 1280428583\n```\n:::\n\n:::\n\n\n::: {#def-}\nA dataset is *tidy* if\n\n1. Each variable have its own column.\n2. Each observation have its own row.\n3. Each value have its oven cell.\n:::\nThese three conditions are interrelated because it is impossible to only satisfy two of the three. In pratical, we need to follow the instructions:\n\n1. Put each dataset in a tibble.\n2. Put each variable in a column.\n\n*Tidy* data is a consistent way to organize your data in R. The main advantages are:\n\n1. It is one consistent way of storing data. In other words, this is a consistent data structure that can be used in many cases.\n2. To placing variables in columns allows R's vectorized nature to shine.\n\nAll packages in the tidyverse are designed to work with tidy data. \n\n### Tidying datasets\nMost datasets are untidy:\n\n- One variable might be spread across multiple columns.\n- One observation might be scattered across multiple rows.\n\n#### `pivot_longer()`\nA common problem is that the column names are not names of variables, but values of a variable. For example, `table4a` above has columns `1999` and `2000`. These two names are actually the values of a variable `year`. In addition, each row represents two observations, not one.\n\n::: {.cell}\n\n```{.r .cell-code}\ntable4a\n#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <dbl>  <dbl>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258 213766\n```\n:::\nTo tidy this type of dataset, we need to gather those columns into a new pair of variables. We need three parameters:\n\n- The set of columns that represent values. In this case, those are `1999` and `2000`.\n- The name of the variable. In this case, it is `year`. \n-The name of the variable whose values are spread over the cells. In this case, it is the number of `cases`. \n\nThen we apply `pivot_longer()`.\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(table4a, cols=c(`1999`, `2000`), names_to='year', values_to='cases')\n#> # A tibble: 6 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <dbl>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258\n#> 6 China       2000  213766\n```\n:::\nWe may also use the pipe `%>%` symbol. \n\n::: {.cell}\n\n```{.r .cell-code}\ntable4a %>% pivot_longer(cols=c(`1999`, `2000`), names_to='year', values_to='cases')\n#> # A tibble: 6 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <dbl>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258\n#> 6 China       2000  213766\n```\n:::\n\n\n\nWe can do the similar thing to `table4b`. Then we could combine the two tibbles together.\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy4a <- table4a %>% \n    pivot_longer(cols=c(`1999`, `2000`), names_to='year', values_to='cases')\ntidy4b <- table4b %>% \n    pivot_longer(cols=c(`1999`, `2000`), names_to='year', values_to='population')\nleft_join(tidy4a, tidy4b)\n#> Joining with `by = join_by(country, year)`\n#> # A tibble: 6 × 4\n#>   country     year   cases population\n#>   <chr>       <chr>  <dbl>      <dbl>\n#> 1 Afghanistan 1999     745   19987071\n#> 2 Afghanistan 2000    2666   20595360\n#> 3 Brazil      1999   37737  172006362\n#> 4 Brazil      2000   80488  174504898\n#> 5 China       1999  212258 1272915272\n#> 6 China       2000  213766 1280428583\n```\n:::\n\n`pivot_longer()` is an updated approach to `gather()`, designed to be both simpler to use and to handle more use cases. We recommend you use `pivot_longer()` for new code; `gather()` isn't going away but is no longer under active development.\n\n\n\n\n#### `pivot_wider()`\nAnother issuse is that an observation is scattered across multiple rows. Take `table2` as an example. \nAn observation is a country in a year, but each observation is spread across two rows.\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2\n#> # A tibble: 12 × 4\n#>    country      year type            count\n#>    <chr>       <dbl> <chr>           <dbl>\n#>  1 Afghanistan  1999 cases             745\n#>  2 Afghanistan  1999 population   19987071\n#>  3 Afghanistan  2000 cases            2666\n#>  4 Afghanistan  2000 population   20595360\n#>  5 Brazil       1999 cases           37737\n#>  6 Brazil       1999 population  172006362\n#>  7 Brazil       2000 cases           80488\n#>  8 Brazil       2000 population  174504898\n#>  9 China        1999 cases          212258\n#> 10 China        1999 population 1272915272\n#> 11 China        2000 cases          213766\n#> 12 China        2000 population 1280428583\n```\n:::\nWe could apply `pivot_wider()` to make it tidy. Here we need two arguments.\n\n- The column that contains variable names. Here, it’s `type`.\n- The column that contains values forms multiple variables. Here, it’s `count`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_wider(table2, names_from='type', values_from='count')\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\nWe can also use the pipe symbol `%>%`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable2 %>% pivot_wider(names_from='type', values_from='count')\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\n\n\n\n\n`pivot_wider()` is an updated approach to `spread()`, designed to be both simpler to use and to handle more use cases. We recommend you use `pivot_wider()` for new code; `spread()` isn't going away but is no longer under active development.\n\n\n#### `separate()`\n\nIf we would like to split one columns into multiple columns since there are more than one values in a cell, we could use `separate()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseparate(table3, rate, into=c('cases', 'population'))\n#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <dbl> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\nWe could also use the pipe symbol `%>%`.\n\n::: {.cell}\n\n```{.r .cell-code}\ntable3 %>% separate(rate, into=c('cases', 'population'))\n#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <dbl> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\n\nUsing separate, the first argument is the column to be separated. `into` is where you store the parsed data. If no arguments are given, `separate()` will split values wherever it sees a non-alphanumeric character. If you would like to specify a separator, you may use the `sep` argument. \n\n- If `sep` is set to be a character, the column will be separated by the character.\n- If `sep` is set to be a vector of integers, the column will be separated by the positions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseparate(table3, rate, into=c('cases', 'population'), sep='/')\n#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <dbl> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseparate(table3, rate, into=c('cases', 'population'), sep=c(2,5))\n#> # A tibble: 6 × 4\n#>   country      year cases population\n#>   <chr>       <dbl> <chr> <chr>     \n#> 1 Afghanistan  1999 74    5/1       \n#> 2 Afghanistan  2000 26    66/       \n#> 3 Brazil       1999 37    737       \n#> 4 Brazil       2000 80    488       \n#> 5 China        1999 21    225       \n#> 6 China        2000 21    376\n```\n:::\n\nNote that in this example, since `into` only has two columns, the rest of the data are lost.\n\nAnother useful argument is `convert`. After separation, the columns are still character columns. If we set `convert=TRUE`, the columns will be automatically converted into better types if possible.\n\n::: {.cell}\n\n```{.r .cell-code}\nseparate(table3, rate, into=c('cases', 'population'), convert=TRUE)\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n:::\n\n\n#### `unite()`\n`unite()` is the inverse of `separate()`. The syntax is straghtforward. The default separator is `_`. \n\n::: {.cell}\n\n```{.r .cell-code}\ntable3 %>% unite(new, year, rate, sep='_')\n#> # A tibble: 6 × 2\n#>   country     new                   \n#>   <chr>       <chr>                 \n#> 1 Afghanistan 1999_745/19987071     \n#> 2 Afghanistan 2000_2666/20595360    \n#> 3 Brazil      1999_37737/172006362  \n#> 4 Brazil      2000_80488/174504898  \n#> 5 China       1999_212258/1272915272\n#> 6 China       2000_213766/1280428583\n```\n:::\n\n\n## `dplyr`\n\n`dplyr` is a package used to manipulate data. Here we will just introduce the most basic functions. We will use `nycflights13::flights` as the example. This dataset comes from the US Bureau of Transportation Statistics. The document can be found [here](https://github.com/tidyverse/nycflights13).\n\nTo load the dataset, please use the following code.\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nycflights13)\nflights\n#> # A tibble: 336,776 × 19\n#>     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#>    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n#>  1  2013     1     1      517            515         2      830            819\n#>  2  2013     1     1      533            529         4      850            830\n#>  3  2013     1     1      542            540         2      923            850\n#>  4  2013     1     1      544            545        -1     1004           1022\n#>  5  2013     1     1      554            600        -6      812            837\n#>  6  2013     1     1      554            558        -4      740            728\n#>  7  2013     1     1      555            600        -5      913            854\n#>  8  2013     1     1      557            600        -3      709            723\n#>  9  2013     1     1      557            600        -3      838            846\n#> 10  2013     1     1      558            600        -2      753            745\n#> # ℹ 336,766 more rows\n#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#> #   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#> #   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n:::\n\n\n### `filter()`\n`filter()` allows you to subset observations based on their values. The first argument is the name of the tibble. The rest are the expressions that filter the data. Please see the following examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% filter(month==1, day==1)\n#> # A tibble: 842 × 19\n#>     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#>    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n#>  1  2013     1     1      517            515         2      830            819\n#>  2  2013     1     1      533            529         4      850            830\n#>  3  2013     1     1      542            540         2      923            850\n#>  4  2013     1     1      544            545        -1     1004           1022\n#>  5  2013     1     1      554            600        -6      812            837\n#>  6  2013     1     1      554            558        -4      740            728\n#>  7  2013     1     1      555            600        -5      913            854\n#>  8  2013     1     1      557            600        -3      709            723\n#>  9  2013     1     1      557            600        -3      838            846\n#> 10  2013     1     1      558            600        -2      753            745\n#> # ℹ 832 more rows\n#> # ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#> #   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#> #   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n:::\n\n\n### `select()`\n`select()` allows you to filter columns. It is very similar to slicing `[]`.\n\n### `mutate()`\n`mutate()` is used to add new columns that are functions of existing columns. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% mutate(gain=arr_delay-dep_delay, hours=air_time/60, gain_per_hour=gain/hours)\n#> # A tibble: 336,776 × 22\n#>     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#>    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n#>  1  2013     1     1      517            515         2      830            819\n#>  2  2013     1     1      533            529         4      850            830\n#>  3  2013     1     1      542            540         2      923            850\n#>  4  2013     1     1      544            545        -1     1004           1022\n#>  5  2013     1     1      554            600        -6      812            837\n#>  6  2013     1     1      554            558        -4      740            728\n#>  7  2013     1     1      555            600        -5      913            854\n#>  8  2013     1     1      557            600        -3      709            723\n#>  9  2013     1     1      557            600        -3      838            846\n#> 10  2013     1     1      558            600        -2      753            745\n#> # ℹ 336,766 more rows\n#> # ℹ 14 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#> #   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#> #   hour <dbl>, minute <dbl>, time_hour <dttm>, gain <dbl>, hours <dbl>,\n#> #   gain_per_hour <dbl>\n```\n:::\nIf you only want to see the new columns, `transmute()` can be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% transmute(gain=arr_delay-dep_delay, hours=air_time/60, gain_per_hour=gain/hours)\n#> # A tibble: 336,776 × 3\n#>     gain hours gain_per_hour\n#>    <dbl> <dbl>         <dbl>\n#>  1     9 3.78           2.38\n#>  2    16 3.78           4.23\n#>  3    31 2.67          11.6 \n#>  4   -17 3.05          -5.57\n#>  5   -19 1.93          -9.83\n#>  6    16 2.5            6.4 \n#>  7    24 2.63           9.11\n#>  8   -11 0.883        -12.5 \n#>  9    -5 2.33          -2.14\n#> 10    10 2.3            4.35\n#> # ℹ 336,766 more rows\n```\n:::\n\nHere are an (incomplete) list of supported operators and functions.\n\n- Arithmetic operators: `+`, `-`, `*`, `/`, `^`.\n- Modular arithmetic: `%/%` (integer division), `%%` (remainder).\n- Logs: `log()`, `log2()`, `log10()`.\n- Cumulative and rolling aggregates: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`, `cummean()`\n- Logical comparisons: `<`, `<=`, `>`, `>=`, `!=`.\n\n\n### `summarize()` and `group_by()`\n\n`summarize()` collapses a dataset to a single row. It computes values across all rows. It is usually paired with `group_by()`. Here are some examples.\n\n\n::: {#exm-}\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% group_by(year, month, day) %>% \n    summarize(delay=mean(dep_delay, na.rm=TRUE))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>     year month   day delay\n#>    <int> <int> <int> <dbl>\n#>  1  2013     1     1 11.5 \n#>  2  2013     1     2 13.9 \n#>  3  2013     1     3 11.0 \n#>  4  2013     1     4  8.95\n#>  5  2013     1     5  5.73\n#>  6  2013     1     6  7.15\n#>  7  2013     1     7  5.42\n#>  8  2013     1     8  2.55\n#>  9  2013     1     9  2.28\n#> 10  2013     1    10  2.84\n#> # ℹ 355 more rows\n```\n:::\n:::\n\n\n::: {#exm-}\n\n::: {.cell}\n\n```{.r .cell-code}\ndelays <- flights %>% \n    group_by(dest) %>% \n    summarize(\n        count=n(), \n        dist=mean(distance, na.rm=TRUE),\n        delay=mean(arr_delay, na.rm=TRUE)\n    ) %>% \n    filter(count>20, dest!='HNL')\ndelays\n#> # A tibble: 96 × 4\n#>    dest  count  dist delay\n#>    <chr> <int> <dbl> <dbl>\n#>  1 ABQ     254 1826   4.38\n#>  2 ACK     265  199   4.85\n#>  3 ALB     439  143  14.4 \n#>  4 ATL   17215  757. 11.3 \n#>  5 AUS    2439 1514.  6.02\n#>  6 AVL     275  584.  8.00\n#>  7 BDL     443  116   7.05\n#>  8 BGR     375  378   8.03\n#>  9 BHM     297  866. 16.9 \n#> 10 BNA    6333  758. 11.8 \n#> # ℹ 86 more rows\n```\n:::\n\n:::\n\n\n\n`group_by()` can also be used together with `mutate()` and `filter()`.\n\n\n::: {#exm-}\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n    group_by(dest) %>%\n    filter(n() > 365) %>%\n    filter(arr_delay > 0) %>%\n    mutate(prop_delay = arr_delay / sum(arr_delay)) %>%\n    select(year:day, dest, arr_delay, prop_delay)\n#> # A tibble: 131,106 × 6\n#> # Groups:   dest [77]\n#>     year month   day dest  arr_delay prop_delay\n#>    <int> <int> <int> <chr>     <dbl>      <dbl>\n#>  1  2013     1     1 IAH          11  0.000111 \n#>  2  2013     1     1 IAH          20  0.000201 \n#>  3  2013     1     1 MIA          33  0.000235 \n#>  4  2013     1     1 ORD          12  0.0000424\n#>  5  2013     1     1 FLL          19  0.0000938\n#>  6  2013     1     1 ORD           8  0.0000283\n#>  7  2013     1     1 LAX           7  0.0000344\n#>  8  2013     1     1 DFW          31  0.000282 \n#>  9  2013     1     1 ATL          12  0.0000400\n#> 10  2013     1     1 DTW          16  0.000116 \n#> # ℹ 131,096 more rows\n```\n:::\n\n:::\n\n\n::: {.callout-note}\nWe already use it in the above examples. This is to compute the number of observations in the current group. This function is implemented specifically for each data source and can only be used from within `summarise()`, `mutate()` and `filter()`.\n:::\n\n## `ggplot2`\n\n\n\n\nThis is the graphing package for R in `tidyverse`. `ggplot2` implements the *grammar of graphics*, a coherent system for describing and building graphs. With `ggplot2`, you can do more faster by learning one system and applying it in many places. The main function is `ggplot()`.\n\n`ggplot2` will be uploaded with `tidyverse`. \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\nWe use the dataset `mpg` as the example. This dataset comes with `ggplot2`. Once you load `ggplot2` you can directly find the dataset by typing `mpg`.\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg\n#> # A tibble: 234 × 11\n#>    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#>    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n#>  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n#>  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n#>  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n#>  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n#>  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n#>  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n#>  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n#>  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n#>  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n#> 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n#> # ℹ 224 more rows\n```\n:::\n\nThe syntax for `ggplot()` is \n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = <DATA>) +\n    <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))\n```\n:::\n\n`ggplot(data=<DATA>)` create a plot without any geometric elements. It simply creates the canvas paired with the dataset.\n\nThen you add one or more layers to `ggplot()` to complete the graph. The function `<GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))` adds a layer to the plot. You may add as many layers as you want. \n\nEach `geom` function takes a `mapping` argument. This defines how variables in the dataset are mapped to visual properties. `mapping` is always paired with `aes(x=, y=)`. This \n\nHere is a quick example.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy))\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n### Aesthetic mappings\n\nAn *aesthetic* is a visual property of the objects in your plot. It include things like the size, the shape or the color of the points. The variables set in `aes()` will change the aesthetic apperance of the geometric objects according to the variables. If the variables are set outside `aes()`, the apperance will be fixed. Please see the following examples.\n\nNote that the variables in `aes()` other than `x` and `y` will automatically get legends.\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy, color = class))\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-37-2.png){width=672}\n:::\n:::\n\n\n### `facet`\nFor categorical data, you can split the plot into `facets`. This `facet` function will be attached as a layer followed by a `+` sign.\n\n- To facet your plot by a single variable, use `facet_wrap()`. The first argument should be a formula, which you create with `~` followed by a variable name.\n- To facet your plot by two variables, use `facet_grid()`. The first argument is a formula which contains two variable names separated by a `~`.\n\n\n::: {#exm-}\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) +\n    facet_wrap(~ class, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\nYou may look at the variables to see the relations with the plot.\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(mpg$class)\n#> [1] \"compact\"    \"midsize\"    \"suv\"        \"2seater\"    \"minivan\"   \n#> [6] \"pickup\"     \"subcompact\"\n```\n:::\n:::\n\n\n\n::: {#exm-}\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) +\n    facet_grid(drv ~ cyl)\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\nYou may look at the variables to see the relations with the plot.\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(mpg$drv)\n#> [1] \"f\" \"4\" \"r\"\nunique(mpg$cyl)\n#> [1] 4 6 8 5\n```\n:::\n\n:::\n\n\n\n::: {.callout-tip}\nThe `~` symbol is used to define a `formula`. The `formula` is a R object, which provide the pattern of a \"formula\". Therefore `drv~cyl` means that `drv` is a function of `cyl`.\n:::\n\n### `geom` objects\n\nA `geom` is the geometrical object that a plot uses to represent data. When drawing plots, you just need to attach those geometrical objects to a `ggplot` canvas with `+` symbol. Some of the geometrical objects can automatically do statistical transformations. The statistical transformations is short for `stat`, and the `stat` argument in those `geom` will show which statistical transformations are applied.\n\n- `geom_point()` draws scatter plot.\n- `geom_smooth()` draws smooth line approximation.\n- `geom_bar()` draws bar plot.\n- `geom_histogram()` draws histogram.\n\nThe arguments can be written in `ggplot()`. All the later `geom` will get those arguments from `ggplot()`. If the arguments are written again in `geom` object, it will override the `ggplot()` arguments.\n\n::: {#exm-}\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy))\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n\n```{.r .cell-code}\n\nggplot(data = mpg) +\n    geom_smooth(mapping = aes(x = displ, y = hwy), formula = y ~ x, method = \"loess\")\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-42-2.png){width=672}\n:::\n\n```{.r .cell-code}\n\nggplot(data = mpg) +\n    geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv), formula = y ~ x, method = \"loess\")\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-42-3.png){width=672}\n:::\n\n```{.r .cell-code}\n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) +\n    geom_smooth(mapping = aes(x = displ, y = hwy), formula = y ~ x, method = \"loess\")\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-42-4.png){width=672}\n:::\n\n```{.r .cell-code}\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n    geom_point(mapping = aes(color = class)) +\n    geom_smooth(\n        data = filter(mpg, class == \"subcompact\"),\n        se = FALSE, \n        formula = y ~ x, method = \"loess\"\n        )\n```\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-42-5.png){width=672}\n:::\n:::\n\n:::\n\n## Exercises\n\n\n::: {#exr-}\nHow can you tell if an object is a tibble?\n:::\n\n\n\n::: {#exr-}\nCompare and contrast the following operations on a `data.frame` and equivalent `tibble`. What is different? Why might the default data frame behaviors cause you frustration?\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(abc = 1, xyz = \"a\")\ndf$x\ndf[, \"xyz\"]\ndf[, c(\"abc\", \"xyz\")]\n\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nIf you have the name of a variable stored in an object, e.g., `var <- \"xyz\"`, how can you extract the reference variable from a tibble? You may use the following codes to get a tibble.\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl <- tibble(abc = 1, xyz = \"a\")\n```\n:::\n\n:::\n\n\n::: {#exr-}\nPractice referring to nonsyntactic names in the following data.frame by:\n\na. Extracting the variable called 1.\nb. Creating a new column called 3, which is 2 divided by 1.\nc. Renaming the columns to one, two, and three:\n\n::: {.cell}\n\n```{.r .cell-code}\nannoying <- tibble(\n`1` = 1:10,\n`2` = `1` * 2 + rnorm(length(`1`))\n)\n```\n:::\n:::\n\n\n\n\n::: {#exr-}\nBoth `unite()` and `separate()` have a `remove` argument. What does it do? Why would you set it to `FALSE`?\n\n:::\n\n\n\n::: {#exr-}\nUse `flights` dataset. Currently `dep_time` and `sched_dep_time` are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.\n:::\n\n\n\n\n\n::: {.cell}\n\n:::\n\n<!-- \n::: {#exr-}\nThis is a Python question. Please download the datasets from here. It is the same datasets as in @exm-tidydatasets. Please use Python to make `\n::: -->\n\n<!-- \n::: {#exr-}\nWhy are `gather()` and `spread()` not perfectly symmetrical? Carefully consider the following example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks <- tibble(\n    year = c(2015, 2015, 2016, 2016),\n    half = c( 1, 2, 1, 2),\n    return = c(1.88, 0.59, 0.92, 0.17)\n)\nstocks %>%\n    spread(year, return) %>%\n    gather(\"year\", \"return\", `2015`:`2016`)\n#> # A tibble: 4 × 3\n#>    half year  return\n#>   <dbl> <chr>  <dbl>\n#> 1     1 2015    1.88\n#> 2     2 2015    0.59\n#> 3     1 2016    0.92\n#> 4     2 2016    0.17\n```\n:::\n(Hint: look at the variable types and think about column `names`.)\n\nBoth `spread()` and `gather()` have a `convert` argument. What does it do?\n::: -->\n\n<!-- \n\n::: {#exr-}\nWhy does this code fail?\n::: {.cell}\n\n```{.r .cell-code}\ntable4a %>%\n    gather(1999, 2000, key = \"year\", value = \"cases\")\n#> Error in `gather()`:\n#> ! Can't subset columns past the end.\n#> ℹ Locations 1999 and 2000 don't exist.\n#> ℹ There are only 3 columns.\n```\n:::\n\n::: -->\n\n\n\n::: {#exr-}\nPlease make the following data tidy.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndf <- tibble(Day=1:5, `Plant_A_Height (cm)`=c(0.5, 0.7, 0.9, 1.3, 1.8), `Plant_B_Height (cm)`=c(0.7, 1, 1.5, 1.8, 2.2))\n```\n:::\n:::\n\n\n\n::: {#exr-}\nPlease use the `flights` dataset. Please find all flights that :\n\n1. Had an arrival delay of two or more hours.\n2. Flew to `IAH` or `HOU`.\n3. Were operated by `United`, `American` or `Delta`.\n4. Departed in summer (July, August, and September).\n5. Arrived more than two hours late, but didn’t leave late.\n6. Were delayed by at least an hour, but made up over 30 minutes in flight.\n7. Departed between midnight and 6 a.m. (inclusive).\n:::\n\n\n\n::: {#exr-}\nRe-create the R code necessary to generate the following graphs. The dataset is `mpg`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-50-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](intro_files/figure-html/unnamed-chunk-50-3.png){width=672}\n:::\n:::\n\n:::\n\n",
    "supporting": [
      "intro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}