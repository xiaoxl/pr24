{
  "hash": "aa53b3782dca9fedec28b454afab87f3",
  "result": {
    "engine": "jupyter",
    "markdown": "# Python Basics\n\n\n\n\n\n## numeric and `str` {#sec-path}\n\nThis section is based on @You2020.\n\nThere are several built-in data structures in Python. Here is an (incomplete) list:\n\n- `None`\n- Boolean -- `True`, `False`\n- Numeric Types — `int`, `float`, `complex`\n- Text Sequence Type — `str`\n- Sequence Types — `list`, `tuple`\n- Map type - `dict`\n\nWe will cover numeric types and strings in this section. The rests are either simple that are self-explained, or not simple that will be discussed later.\n\n\n\n### Numeric types and math expressions\nNumeric types are represented by numbers. If there are no confusions, Python will automatically detect the type. \n\n::: {#f6c083ef .cell execution_count=1}\n``` {.python .cell-code}\nx = 1 # x is an int.\ny = 2.0 # y is a float.\n```\n:::\n\n\nThere are several types of numeric types, like `int`, `float`, etc.. Usually Python will automatically determine the type of the data, but sometimes you may still want to declare them manually. To change types you may apply `int()`, `float()`, etc. to the values you want to change.\n\nPython can do math just like other programming languages. The basic math operations are listed as follows.\n\n- `+`, `-`, `*`, `/`, `>`, `<`, `>=`, `<=` works as normal.\n- `**` is the power operation.\n- `%` is the mod operation.\n- `!=` is `not equal`\n\n\n\n::: {.callout-caution collapse=\"true\"}\n## `==` and `is`\n\nPython is centered around objects. There are differences between two objects and the values of two objects. \n\n- `==` is testing whehter these two objects have the same value.\n- `is` is testing whether these two objects are exactly the same.\n\nYou may use `id(x)` to check the id of the object `x`. Two objects are identical if they have the same id. Please see the following example.\n\n`a` and `b` are two lists. They are different objects, but their contents are the same.\n\n::: {#a414eb54 .cell execution_count=2}\n``` {.python .cell-code}\na = [1, 2]\nb = [1, 2]\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#3f633c0e .cell execution_count=3}\n``` {.python .cell-code}\na is b\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nFalse\n```\n:::\n:::\n\n\nYou may check their ids and find that their ids are different.\n\n::: {#ffd38102 .cell execution_count=4}\n``` {.python .cell-code}\nid(a) == id(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nFalse\n```\n:::\n:::\n\n\nFor beginners, in most cases, you should use `==` to check values of variables. The most common case to use `is` is to check whether something is a `None` object. In other words, you should use `a is None` other than `a == None`.\n\nMore details about objects will be discussed later in this course.\n:::\n\n\n\n### `str`\nScalars are represented by numbers and strings are represented by quotes. Examples:\n\n::: {#cfdfcd9a .cell execution_count=5}\n``` {.python .cell-code}\nx = 1       # x is a scalar.\ny = 's'     # y is a string with one letter.\nz = '0'     # z loos like a number, but it is a string.\nw = \"Hello\" # w is a string with double quotes.\n```\n:::\n\n\nHere are some facts.\n\n1. For strings, you can use either single quotes `'` or double quotes `\"`. The tricky part here is that you may use `'` in `\"`, or `\"` in `'`. If you want to use `'` in `'` or `\"` in `\"`, use `\\` below.\n2. `\\` is used to denote escaped words. You may find the list [here](https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals). \n3. You can use `str()` to change other values to a string, if able.\n4. You may use `string[n]` to read the nth letter of `string`. Note that the index starts from `0`. This part is very similar to list. We will come back to it later after we talked about list.\n\n::: {#7cfb13ff .cell execution_count=6}\n``` {.python .cell-code}\ns = 'abcdef'\ns[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'd'\n```\n:::\n:::\n\n\n5. To concatenate two strings, you may simply use `+`. See the following example.\n\n::: {#1e006349 .cell execution_count=7}\n``` {.python .cell-code}\ns = 'abc' + 'def'\ns\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n'abcdef'\n```\n:::\n:::\n\n\n6. We can also multiply a string with a positive integer. What it does is to repeat the string multiple times. See the following example.\n\n::: {#acbf9cb0 .cell execution_count=8}\n``` {.python .cell-code}\ns = 'abc'*5\ns\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n'abcabcabcabcabc'\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## `.format()` method\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the `.format()` method. The basic syntax is to use the inputed augments to fill in the blanks in the formatted string specified by `{}`. Please see the following examples.\n\n::: {#81921373 .cell execution_count=9}\n``` {.python .cell-code}\n'I have {} {} and {} {}.'.format(1, 'apple', 2, 'bananas')\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n'I have 1 apple and 2 bananas.'\n```\n:::\n:::\n\n\nMore detailed usage is refered to the official documents [here](https://docs.python.org/3/library/string.html#custom-string-formatting). \n\n:::\n\n\nAlthough `str` is a built-in type, there are tons of tricks with `str`, and there are tons of packages related to strings. Generally speaking, to play with strings, we are interested in two types of tasks.\n\n- Put information together to form a string.\n- Extract information from a string.\n\nA lot of tricks of strings are related to lists. We will talk about these two tasks later. The following example is just a showcase.\n\n\n<!-- ::: {.callout-note}\nThere is a very subtle relations between the variable / constant and the name of the variable / constant. We will talk about these later.\n::: -->\n\n\n::: {#exm-}\nHere is an example of playing with strings. Please play with these codes and try to understand what they do.\n\n::: {#60159840 .cell execution_count=10}\n``` {.python .cell-code}\nimport re\n\ndef clean_strings(strings):\n    result = []\n    for value in strings:\n        value = value.strip()\n        value = re.sub('[!#?]', '', value)\n        value = value.title()\n        result.append(value)\n    return result\n\nstates = [' Alabama ', 'Georgia!', 'Georgia', 'georgia', 'FlOrIda',\n          'south carolina##', 'West virginia?']\nclean_strings(states)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n['Alabama',\n 'Georgia',\n 'Georgia',\n 'Georgia',\n 'Florida',\n 'South Carolina',\n 'West Virginia']\n```\n:::\n:::\n\n\n:::\n\n\n\n\n\n## Fundamentals\nThis section is mainly based on @McK2017.\n\n### Indentation\nOne key feature about Python is that its structures (blocks) is determined by **Indentation**. \n\nLet's compare with other languages. Let's take `C` as an example.\n```C\n/*This is a C function.*/\nint f(int x){return x;}\n```\nThe block is defined by `{}` and lines are separated by `;`. `space` and `newline` are not important when `C` runs the code. It is recommended to write codes in a \"beautiful, stylish\" format for readibility, as follows. However it is not mandatory.\n```C\n/*This is a C function.*/\nint f(int x) {\n   return x;\n}\n```\n\nIn Python, blocks starts from `:` and then are determined by indents. Therefore you won't see a lot of `{}` in Python, and the \"beautiful, stylish\" format is **mandatory**. \n\n::: {#04780bbe .cell execution_count=11}\n``` {.python .cell-code}\n# This is a Python function.\ndef f(x):\n    return x\n```\n:::\n\n\nThe default value for indentation is 4 spaces, which can be changed by users. We will just use the default value in this course.\n\n\n::: {.callout-note collapse=\"true\"}\n## Line break\n\nIt is usually recommended that one line of code should not be very long. If you do have one, and it cannot be shortened, you may break it into multiline codes directly in Python. However, since indentation is super important in Python, when break one line code into multilines, please make sure that everything is aligned perfectly. Please see the following example.\n\n::: {#eb2b7f67 .cell execution_count=12}\n``` {.python .cell-code}\nresults = shotchartdetail.ShotChartDetail(\n            team_id = 0,\n            player_id = 201939,\n            context_measure_simple = 'FGA',\n            season_nullable = '2021-22',\n            season_type_all_star = 'Regular Season')\n```\n:::\n\n\nSimilarly for long strings, you may use `\\` to break it into multiple lines. Here is one example.\n\n::: {#36af9469 .cell execution_count=13}\n``` {.python .cell-code}\nsentence = \"This is\\ngood enough\\nfor a exercise to\\nhave so many parts. \" \\\n           \"We would also want to try this symbol: '. \" \\\n           \"Do you know how to type \\\" in double quotes?\"\n```\n:::\n\n\n:::\n\n\n\n\n\n### `import`\n\nIn Python a module is simply a file with the .py extension containing Python code. Assume that we have a Python file `example.py` stored in the folder `assests/codes/`. The file is as follows.\n\n```{.python filename='assests/codes/example.py'}\ndef f(x):\n    print(x)\n\nA = 'You found me!'\n```\nYou may get access to this function and this string in the following way.\n\n::: {#d3ae72b6 .cell execution_count=14}\n``` {.python .cell-code}\nfrom assests.codes import example\n\nexample.f(example.A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nYou found me!\n```\n:::\n:::\n\n\n### Comments\n\nAny text preceded by the hash mark (pound sign) `#` is ignored by the Python interpreter. In many IDEs you may use hotkeys to directly toggle multilines as comments. For example, in VS Code the default setting for toggling comments is `ctrl+/`.\n\n\n### Dynamic references, strong types\n\nIn some programming languages, you have to declare the variable’s name and what type of data it will hold. If a variable is declared to be a number, it can never hold a different type of value, like a string. This is called *static typing* because the type of the variable can never change.\n\nPython is a *dynamically typed* language, which means you do not have to declare a variable or what kind of data the variable will hold. You can change the value and type of data at any time. This could be either great or terrible news. \n\nOn the other side, \"dynamic typed\" doesn't mean that types are not important in Python. You still have to make sure that the types of all variables meet the requirements of the operations used.\n\n::: {#a9e4760b .cell execution_count=15}\n``` {.python .cell-code}\na = 1\nb = 2\nb = '2'\nc = a + b\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n```\n:::\n:::\n\n\nIn this example, `b` was first assigned by a number, and then it was reassigned by a `str`. This is totally fine since Python is dynamically typed. However later when adding `a` and `b`, the type error occurs since you cannot add a number and a `str`.\n\n\n::: {.callout-note}\nYou may always use `type(x)` to detect the type of the object `x`.\n:::\n\n\n\n### Everything is an object\n\nEvery number, string, data structure, function, class, module, and so on exists in the Python interpreter in its own “box”, which is referred to as a *Python object*. \n\nEach object has an associated type (e.g., string or function) and internal data. In practice this makes the language very flexible, as even functions can be treated like any other object.\n\nEach object might have attributes and/or methods attached. \n\n\n### Mutable and immutable objects\nAn object whose internal state can be changed is *mutable*. On the other hand, *immutable* doesn’t allow any change in the object once it has been created. \n\nSome objects of built-in type that are mutable are:\n\n- Lists\n- Dictionaries\n- Sets\n\n\nSome objects of built-in type that are immutable are:\n\n- Numbers (Integer, Rational, Float, Decimal, Complex & Booleans)\n- Strings\n- Tuples\n\nIn the following courses, you will learn some of these objects. You will see that for mutable objects, there are built-in methods to modify them, like `.append()` for `list`, which append element to the end of a list. There are none for immutable objects.\n\n::: {.callout-caution collapse=\"true\"}\n## A tricky case: Tuples are not really \"immutable\"\nYou can treat a tuple as a container, which contains some objects. The relations between the container and its contents are immutable, but the objects it holds might be mutable. Please check the following example.\n\n::: {#a2ea1f36 .cell execution_count=16}\n``` {.python .cell-code}\ncontainer = ([1], [2])\nprint('This is `container`: ', container)\nprint('This is the id of `container`: ', id(container))\nprint('This is the id of the first list of `container`: ', id(container[0]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is `container`:  ([1], [2])\nThis is the id of `container`:  2088221702272\nThis is the id of the first list of `container`:  2088221574784\n```\n:::\n:::\n\n\n::: {#2bc9a621 .cell execution_count=17}\n``` {.python .cell-code}\ncontainer[0].append(2)\nprint('This is the new `container`: ', container)\nprint('This is the id of the new `container`: ', id(container))\nprint('This is the id of the first list (which is updated) of the new `container`: ', id(container[0]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is the new `container`:  ([1, 2], [2])\nThis is the id of the new `container`:  2088221702272\nThis is the id of the first list (which is updated) of the new `container`:  2088221574784\n```\n:::\n:::\n\n\nYou can see that the tuple `container` and its first object stay the same, although we add one element to the first object.\n\nYou may understand how objects are stored by considering this example.\n:::\n\n\n\n\n## Flows and Functions\n\n### `for` loop\nA `for` loop is used for iterating over an *iterator*. Iterators can be gotten from lists, tuples, strings, etc.. The basic syntax of a `for` loop is as follows.\n\n::: {#2ef0fa88 .cell execution_count=18}\n``` {.python .cell-code}\nfor i in aniterator:\n    do thing\n```\n:::\n\n\nIn each iteration, the `aniterator` will produce a value and assign it to `i`. Then the code in the `for` loop will run with `i` being assigned to the specific value. \n\nLet's look at some typical examples of iterators.\n\n::: {.callout-note collapse=\"true\"}\n# `range()`\n`range(N)` is an iterator which will produce integers from `0` to `N-1`. This is the most basic way to use `for` loop that you may treat `i` as the index of an iteration. Note that similar to the list index rule (which will be discussed later), the right end point `N` is not included.\n\n::: {#13aba9cc .cell execution_count=19}\n``` {.python .cell-code}\nfor i in range(3):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0\n1\n2\n```\n:::\n:::\n\n\nThere are two more versions of `range()`:\n\n- `range(M, N)` can generate integers from `M` to `N-1`.\n- `range(M, N, s)` can generate integers from `M` to `N-1`, with the step size `s`.\nSimilarly, in both cases, the right end point `N` is not included.\n\n::: {#b8908cf5 .cell execution_count=20}\n``` {.python .cell-code}\nfor i in range(1, 3):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n```\n:::\n:::\n\n\n::: {#6df8caf7 .cell execution_count=21}\n``` {.python .cell-code}\nfor i in range(1, 5, 2):\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n3\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# Strings\nYou may use a string as an iterator. It will go through the string and generate the letter in it one by one from the beginning to the end. Note that escaped letters will be captured. Please see the following example.\n\n::: {#a8d18152 .cell execution_count=22}\n``` {.python .cell-code}\ns = 'abc\\\"'\nfor i in s:\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\nb\nc\n\"\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# Lists\nWe will talk about lists in details in next section. We will briefly mention it here since lists are the most common iterators in Python. Roughly speaking, a list is an ordered sequence of Python objects. As an iterator, it just goes through the sequence and generates the object in it one by one from the beginning to the end. Please see the following example.\n\n::: {#ce674cd3 .cell execution_count=23}\n``` {.python .cell-code}\ns = [1, 'a', -3.1, 'abc']\nfor i in s:\n    print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\na\n-3.1\nabc\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n# `zip()`\nThe \"Pythonic way\" to write loops is to NOT use indexes. In this case how do we loop through two iterators if no indexes are used? We could use `zip()`.\n\n`zip()` is used to \"zip\" two iterators together to form one. Then we can use the zipped one for the loop and elements from both iterators are zipped into tuples. Please see the following examples.\n\n::: {#2986483a .cell execution_count=24}\n``` {.python .cell-code}\na = [1, 2, 3]\nb = ['a', 'b', 'c']\nfor item in zip(a, b):\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(1, 'a')\n(2, 'b')\n(3, 'c')\n```\n:::\n:::\n\n\n::: {#d89cf8a7 .cell execution_count=25}\n``` {.python .cell-code}\nc = range(3)\nd = 'abc'\nfor item in zip(c, d):\n    print(item)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(0, 'a')\n(1, 'b')\n(2, 'c')\n```\n:::\n:::\n\n\n:::\n\n\n### `if` statement\nThe `if` statement is straightforword. Here is a typical example.\n\n::: {#7dfde1e0 .cell execution_count=26}\n``` {.python .cell-code}\nx = -1\n\nif x < 0:\n    x = 0\n    print('Negative changed to zero')\nelif x == 0:\n    print('Zero')\nelif x == 1:\n    print('Single')\nelse:\n    print('More')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNegative changed to zero\n```\n:::\n:::\n\n\nThere can be zero or more `elif` parts, and the `else` part is optional.\n\n### Functions\n\nFunctions are declared with the `def` keyword and returned from the `return` keyword. Here is a typical example of a function.\n\n::: {#fd32f538 .cell execution_count=27}\n``` {.python .cell-code}\ndef my_function(x, y, z=1.5):\n    if z > 1:\n        return z * (x + y)\n    else:\n        return z / (x + y)\n```\n:::\n\n\nEach function can have *positional* arguments and *keyword* arguments. \n\n- `z=1.5` in above example means that the default value for `z` is `1.5`. Keyword arguments are most commonly used to specify default values.\n- If no keywords are given, all arguments will be recognized by the positions.\n- If both positional arguments and keyword arguments are given, positional arguments have to be in front. \n- The order of keyword arguments are not important.\n\n\n::: {.callout-note}\nAlthough there are global variable, it is always ecouraged to use local variables only. This means that the variables in and out of a function (as well as classes that we will talk about later) are not the same, even if they have the same name.\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Lambda function\n*lambda* function is a way of writing functions consisting of a single statment. The format is `lambda x: output of x`. \n\nPlease see the following examples.\n\n::: {#56fa2cd0 .cell execution_count=28}\n``` {.python .cell-code}\nf = lambda x: 2*x+1\n\nf(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n7\n```\n:::\n:::\n\n\n::: {#d6eee2ac .cell execution_count=29}\n``` {.python .cell-code}\ndef apply_to_list(some_list, f):\n    return [f(x) for x in some_list]\n\nints = [4, 0, 1, 5, 6]\napply_to_list(ints, lambda x: x * 2)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n[8, 0, 2, 10, 12]\n```\n:::\n:::\n\n\nTo fully understand the following example requires knowledge from @sec-dict.\n\n::: {#da04e657 .cell execution_count=30}\n``` {.python .cell-code}\nfruits = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\n\nfruits_sorted = sorted(fruits.items(), key=lambda x: x[1])\nfruits_sorted\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n[('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)]\n```\n:::\n:::\n\n\nLambda function is always used as a input parameter when it is not worth to use extra space to write a one line function. You will see several examples in the Chapter of `pandas`.\n\n:::\n\n\n\n\n\n::: {.callout-caution collapse=\"true\"}\n## This is a tricky but not very rare case: mutable objects as default values.\nIt is highly recommended NOT to set any mutatable objects as the default value of an input of a function. The reason is that this default object is initialized when the function is defined, not when the function is called. Then all function calls will share the same default object.\n\nA typical example is an empty list. If you use an empty list as the defaul value, that list will be passed to the next function call, which is no longer empty. Please see the following example.\n\n::: {#dc3330e7 .cell execution_count=31}\n``` {.python .cell-code}\ndef add(x=[]):\n    x.append(1)\n    return x\n\nadd()\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n[1]\n```\n:::\n:::\n\n\n::: {#594dc19e .cell execution_count=32}\n``` {.python .cell-code}\nadd()\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n[1, 1]\n```\n:::\n:::\n\n\n::: {#c28b33f5 .cell execution_count=33}\n``` {.python .cell-code}\nadd()\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n[1, 1, 1]\n```\n:::\n:::\n\n\nEvery time the function is called with no arguments, the default value is used, which is the same list initialized at the beginning. The list at the begining is an empty list. But after we put things inside, it is no longer empty.\n\nIf you want to set a mutable object as a default, the way is as follows:\n\n::: {#552820e6 .cell execution_count=34}\n``` {.python .cell-code}\ndef add(x=None):\n    if x is None:\n        x = list()\n    x.append(1)\n    return x\n\nadd()\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n[1]\n```\n:::\n:::\n\n\n::: {#4ef8f421 .cell execution_count=35}\n``` {.python .cell-code}\nadd()\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n[1]\n```\n:::\n:::\n\n\n::: {#49fa34c5 .cell execution_count=36}\n``` {.python .cell-code}\nadd()\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n[1]\n```\n:::\n:::\n\n\n:::\n\n\n## `list` \n\n`list` is a basic Python data structure. It is an ordered sequence of object types, and it is denoted by `[]`. A typical list example is `[0, 1, 2]`, which is a 3-element list.\n\nMain questions in `list` contain creating, indexing and applications.\n\n### Creating lists\n\nThere are two built-in methods to create lists. \n\n::: {.callout-note collapse=\"true\"}\n# Naive way \nA `list` can be created simply by writing down all the elements in order and enclosed by `[]`. Please see the following typical example.\n\n::: {#c9f0811b .cell execution_count=37}\n``` {.python .cell-code}\nL = [0, 1, 2]\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n[0, 1, 2]\n```\n:::\n:::\n\n\nAn empty list can be denoted by `[]`. \n:::\n\n::: {.callout-note collapse=\"true\"}\n# Use `list()` to convert objects into a list\n\nSimilar to the type change for numeric types and `str`, you may use `list()` to convert other objects into a list, if able. The typical example is to convert other iterators into lists.\n\n::: {#b60b1e95 .cell execution_count=38}\n``` {.python .cell-code}\ns = 'abc'\nlist(s)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n['a', 'b', 'c']\n```\n:::\n:::\n\n\n::: {#55a5d94a .cell execution_count=39}\n``` {.python .cell-code}\nr = range(1, 6, 2)\nlist(r)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n[1, 3, 5]\n```\n:::\n:::\n\n\n::: {#4891e69e .cell execution_count=40}\n``` {.python .cell-code}\nlist(zip(s, r))\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n[('a', 1), ('b', 3), ('c', 5)]\n```\n:::\n:::\n\n\nEmpty list can be created by `list()`.\n:::\n\n::: {.callout-tip}\nThe real difference between this above two methods are very subtle. You may just focus on which one can create the list you want, for now.\n:::\n\n\n\n\n### Indexing\nThere are two ways to get access to elements in a list: by position or by slice. \n\n\n::: {.callout-note collapse=\"true\"}\n## By position\n\nLet `L` be a list. Then `L[i]` will return the `i`-th element in the list. \n\n- All index in Python starts from `0`. Therefore the first element is `L[0]`, the second is `L[1]`, etc..\n- Negative position means go backwards. So `L[-1]` means the last element, `L[-2]` means the second last element, etc..\n\n::: {#6f68517d .cell execution_count=41}\n``` {.python .cell-code}\nL = [1, 2, 3]\nL[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n1\n```\n:::\n:::\n\n\n::: {#c1830925 .cell execution_count=42}\n``` {.python .cell-code}\nL[-2]\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n2\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## By slicing\n`slice` is a Python object. It looks like `slice(start, stop, step)`. It represents an arithematic sequence, which starts from `start`, ends before `stop` with a step size `step`. The default step size is `1`. For example, `slice(0, 5, 1)` represents an arithematic sequence `0`, `1`, `2`, `3`, `4`. Note that `slice(0, 5, 1)` itself is a slice object, and it is NOT the list `[0, 1, 2, 3, 4]`. \n\nLet `L` be a list, and `s=slice(start, stop, step)` be a slice. `L[s]` is the portion of the original list `L` given by the index indicated by the slice `s`, as a list. A common way to write slice is through `:`. When slicing a list, you may also use \n\n::: {#fca9f421 .cell execution_count=43}\n``` {.python .cell-code}\nL[start:stop:step]\n```\n:::\n\n\n1. The slice ends before `stop`. Therefore the right end point `stop` is not in the slice.\n2. If `step` is not specified, `step=1` is the default value.\n3. If `start` or `stop` is not specified, the default value is the first of the list or the last.\n4. `start` and `stop` follows the rules of negative positions. \n5. When slicing, the result is always a list, even if it only contains one element.\n\n::: {#a5458a82 .cell execution_count=44}\n``` {.python .cell-code}\nL = ['a', 'b', 'c', 'd', 'e']\nL[1:5:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n['b', 'd']\n```\n:::\n:::\n\n\n::: {#bf197ff9 .cell execution_count=45}\n``` {.python .cell-code}\nL[1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n['b', 'c']\n```\n:::\n:::\n\n\n::: {#10068d63 .cell execution_count=46}\n``` {.python .cell-code}\nL[:-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n['a', 'b', 'c', 'd']\n```\n:::\n:::\n\n\n::: {#6e3eaf70 .cell execution_count=47}\n``` {.python .cell-code}\nL[-1:0:-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n['e', 'd', 'c', 'b']\n```\n:::\n:::\n\n\n:::\n\n\n\n### Methods\n\n::: {.callout-note collapse=\"true\"}\n## `in`\n`in` is used to check whether one object is in a list. Please see the following example.\n\n::: {#96a2ceed .cell execution_count=48}\n``` {.python .cell-code}\nL = ['1', '2', '3']\n'1' in L\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#8b82379a .cell execution_count=49}\n``` {.python .cell-code}\n1 in L\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\nFalse\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## `.append()`\n`.append()` method is used to add one object to the list. The default setting is to add the object to the end of the list. Please see the following example.\n\n::: {#b5341c72 .cell execution_count=50}\n``` {.python .cell-code}\nL = [1, 2, 3]\nL.append(4)\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\n[1, 2, 3, 4]\n```\n:::\n:::\n\n\nNote that you may input any Python object. If appending another list, that list will be treated as an object. Please see the following example.\n\n::: {#819b176b .cell execution_count=51}\n``` {.python .cell-code}\nL = [1, 2, 3]\nL.append([4, 5])\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n[1, 2, 3, [4, 5]]\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## `.extend()` and `+`\n`.extend()` method is used to extend the original list by another list. The input has to be a list. Please see the following example.\n\n::: {#6befe14f .cell execution_count=52}\n``` {.python .cell-code}\nL = [1, 2, 3]\nL.extend([4, 5])\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n[1, 2, 3, 4, 5]\n```\n:::\n:::\n\n\n::: {#c42d2794 .cell execution_count=53}\n``` {.python .cell-code}\nL = [1, 2, 3]\nL.extend(4)\nL\n```\n\n::: {.cell-output .cell-output-error}\n```\nTypeError: 'int' object is not iterable\n```\n:::\n:::\n\n\nYou may use `+` to represent `.extend()`. Please see the following example. It is exactly the same as `[1, 2, 3].extend(['a', 'b'])`.\n\n::: {#784b702a .cell execution_count=54}\n``` {.python .cell-code}\n[1, 2, 3] + ['a', 'b']\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n[1, 2, 3, 'a', 'b']\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## `del`, `.remove()` and `.pop()`\nThere are multiple ways to remove an element from a list.\n\n- `.remove()` is a `list` method, that is used as `L.remove(a)`. It removes element in-place and is based on values. In other words, it will remove the first element whose value equals to `a`.\n\n::: {#41f47208 .cell execution_count=55}\n``` {.python .cell-code}\nL = [2, 3, 1, 3, 1, 2]\nL.remove(1)\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n[2, 3, 3, 1, 2]\n```\n:::\n:::\n\n\n- `.pop()` is also a `list` method. It removes element in-place, is based on position index, and will return the element removed. The default choice is to pop the last element.\n\n::: {#ad28fcdf .cell execution_count=56}\n``` {.python .cell-code}\nL = [1, 2, 3, 4]\nelement_popped = L.pop()\nelement_popped\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n4\n```\n:::\n:::\n\n\n::: {#efe5b74d .cell execution_count=57}\n``` {.python .cell-code}\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\n::: {#7d621fea .cell execution_count=58}\n``` {.python .cell-code}\nL = [1, 2, 3, 4]\nelement_popped = L.pop(2)\nelement_popped\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n3\n```\n:::\n:::\n\n\n::: {#6a30d3f1 .cell execution_count=59}\n``` {.python .cell-code}\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n[1, 2, 4]\n```\n:::\n:::\n\n\n- `del` is a Python command, that is used to delete elements in a `list` based on position index. \n\n::: {#2eed7651 .cell execution_count=60}\n``` {.python .cell-code}\nL = [3, 1, 2, 1, 2, 3]\ndel L[3]\nL\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\n[3, 1, 2, 2, 3]\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=true}\n## `sorted()` and `.sort()`\nLet `L` be a list of numbers. We could use `sorted(L)` or `L.sort()` to sort this list `L`. \n\n- `sorted()` is a Python built-in function. The syntax is straightforward.\n\n::: {#631b4d28 .cell execution_count=61}\n``` {.python .cell-code}\na = [3, 1, 2]\nb = sorted(a)\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\n- `.sort()` is a `list` method. It sorts the list in place.\n\n::: {#e71ddfb4 .cell execution_count=62}\n``` {.python .cell-code}\na = [3, 1, 2]\na.sort()\na\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nNote that `a.sort()` doesn't have any return values. `a` is altered during the process. If you want to catch the return value, you will get a `None` object.\n\n::: {#608bff35 .cell execution_count=63}\n``` {.python .cell-code}\nb = a.sort()\nb is None\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.callout-caution}\n## The importance of documents\nThis example shows that similar functions may behaves differently. It is actually very hard to predict what would happen since it all depends on how the developer of the function thinks about the problems.\n\nTherefore it is very important to know how to find references. Other than simply asking questions on StackOverflow or other forums, the official documents are always your good friend. For example, you may find how these two functions work from [`sorted()`](https://docs.python.org/3/library/functions.html#sorted) and [`.sort()`](https://docs.python.org/3/library/stdtypes.html#list.sort).\n:::\n\n:::\n\n\n### Work with `str`\nThere are many operations of `str` are related to `list`.\n\n\n::: {.callout-note collapse=\"true\"}\n## Slicing\nWe already mentioned that we could use `s[n]` to get the nth letter of a string `s`. Similarly we could use slice to get part of a string. Note that the index shares the same rule as lists.\n\n::: {#114aa406 .cell execution_count=64}\n``` {.python .cell-code}\ns = 'abcdef'\ns[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\n'b'\n```\n:::\n:::\n\n\n::: {#b421065f .cell execution_count=65}\n``` {.python .cell-code}\ns[1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\n'bc'\n```\n:::\n:::\n\n\n::: {#d7db42b9 .cell execution_count=66}\n``` {.python .cell-code}\ns[1:5:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=62}\n```\n'bd'\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse='true'}\n## `.split()`\n`split` is used to split a string `original_string` by a given substring `sep`. The result is a list of the remaining parts. The syntax is \n\n::: {#93fcfa74 .cell execution_count=67}\n``` {.python .cell-code}\noriginal_string.split(sep)\n```\n:::\n\n\nPlease see the following example.\n\n::: {#da8c8491 .cell execution_count=68}\n``` {.python .cell-code}\ns = 'abcabcadedeb'\ns.split('b')\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```\n['a', 'ca', 'cadede', '']\n```\n:::\n:::\n\n\nNote that the last element of the result is an empty string `''` since the last letter of `s` is `b`.\n\n::: {#86c5c16a .cell execution_count=69}\n``` {.python .cell-code}\ns = 'abcabcadedeb'\ns.split('ca')\n```\n\n::: {.cell-output .cell-output-display execution_count=64}\n```\n['ab', 'b', 'dedeb']\n```\n:::\n:::\n\n\n::: {.callout-tip}\nThis `.split()` is a very simple way to recognize patterns in a string. To fully explore this topic, the best practice is to use regular expressions.\n:::\n:::\n\n\n\n::: {.callout-note collapse='true'}\n## `.join()`\nLet `L` be a list of strings. We could connect them together to form a single string, by using `.join()`. We could put a separator string `sep` between each part in the list `L`. The result is the connected string. The syntax is \n\n::: {#ba8ba4a2 .cell execution_count=70}\n``` {.python .cell-code}\nsep.join(L)\n```\n:::\n\n\nPlease see the following example.\n\n::: {#0f2f2cc3 .cell execution_count=71}\n``` {.python .cell-code}\nL = ['a', 'b', 'c', 'd']\n'+'.join(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\n'a+b+c+d'\n```\n:::\n:::\n\n\n::: {#d64f70ad .cell execution_count=72}\n``` {.python .cell-code}\n''.join(L)\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\n'abcd'\n```\n:::\n:::\n\n\nNote that in this example the separtor string is an empty string.\n:::\n\n\n## `dict` {#sec-dict}\n\nDictionary `dict` is also very important built-in Python data structure. It is a flexibly sized collection of *key-value* pairs, where key and value are Python objects. One approach for creating a dictionary is to use `{}` and colons to separate keys and values.\n\n::: {#ef7c5f84 .cell execution_count=73}\n``` {.python .cell-code}\nexample = {'a': 'value',\n           'b': 1,\n           3: 'a',\n           4: [1, 2 ,3],}\n```\n:::\n\n\nYou can access, insert, or set elements using the same syntax as for accessing elements\nof a list.\n\n::: {#4034ef1d .cell execution_count=74}\n``` {.python .cell-code}\nexample['a']\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\n'value'\n```\n:::\n:::\n\n\n::: {#7a636233 .cell execution_count=75}\n``` {.python .cell-code}\nexample[4]\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Checking keys\nWe can directly use `in` to check whether a dict contains a key.\n\n::: {#4eca681b .cell execution_count=76}\n``` {.python .cell-code}\n'a' in example\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#9cdbd461 .cell execution_count=77}\n``` {.python .cell-code}\n1 in example\n```\n\n::: {.cell-output .cell-output-display execution_count=71}\n```\nFalse\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## `.keys()`, `.values()` and `.items()`\nWe could use `.keys()` to get all keys. The result is actually an iterator. We could either loop through it using `for`, or simply convert it to a list by `list()`.\n\n::: {#0539392d .cell execution_count=78}\n``` {.python .cell-code}\nlist(example.keys())\n```\n\n::: {.cell-output .cell-output-display execution_count=72}\n```\n['a', 'b', 3, 4]\n```\n:::\n:::\n\n\nSimilarly, to get all values, we could use `.values()` method. What we get is an iterator, and we could convert it to a list.\n\n::: {#c26a982d .cell execution_count=79}\n``` {.python .cell-code}\nlist(example.values())\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```\n['value', 1, 'a', [1, 2, 3]]\n```\n:::\n:::\n\n\nSimilar to the previous two, `.items()` is used to get key-value pairs, in the same style.\n\n::: {#86a95971 .cell execution_count=80}\n``` {.python .cell-code}\nlist(example.items())\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\n[('a', 'value'), ('b', 1), (3, 'a'), (4, [1, 2, 3])]\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Update dictionaries\n\n1. To update a key-value pair, you may directly write\n\n::: {#1fe10bed .cell execution_count=81}\n``` {.python .cell-code}\ndictionary[key] = value\n```\n:::\n\n\nIf this `key` exists, the key-value pair will be updated. If this `key` doesn't exist, this key-value pair will be added to the dictionary. See the following examples.\n\n::: {#63a2d6b0 .cell execution_count=82}\n``` {.python .cell-code}\nexample['a'] = 'newvalue'\nexample\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\n{'a': 'newvalue', 'b': 1, 3: 'a', 4: [1, 2, 3]}\n```\n:::\n:::\n\n\n::: {#68d0537c .cell execution_count=83}\n``` {.python .cell-code}\nexample['newkey'] = 'good!'\nexample\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\n{'a': 'newvalue', 'b': 1, 3: 'a', 4: [1, 2, 3], 'newkey': 'good!'}\n```\n:::\n:::\n\n\n2. To merge with another `dict`, you may use `.update()` method. This is very similar to `.extend()` for `list`. Note that if the same key exists in both dictionaries, the old value will be updated by the new one. Please see the following example.\n\n::: {#68f0a2e5 .cell execution_count=84}\n``` {.python .cell-code}\nexample.update({'a': 'new', 10: [1, 2], 11: 'test'})\nexample\n```\n\n::: {.cell-output .cell-output-display execution_count=77}\n```\n{'a': 'new',\n 'b': 1,\n 3: 'a',\n 4: [1, 2, 3],\n 'newkey': 'good!',\n 10: [1, 2],\n 11: 'test'}\n```\n:::\n:::\n\n\n:::\n\n## More advanced topics\n\n### `list`/`dict` comprehension\n`list` comprehension is a convenient way to create lists based on the values of an existing `list`. It cannot provide any real improvement to the performance of the codes, but it can make the codes shorter and easier to read.\n\nThe format of `list` comprehension is\n\n::: {#002d1997 .cell execution_count=85}\n``` {.python .cell-code}\nnewlist = [expression for item in iterable if condition == True]\n```\n:::\n\n\nIt is equivalent to the folowing code:\n\n::: {#f2e67006 .cell execution_count=86}\n``` {.python .cell-code}\nnewlist = []\nfor item in iterable:\n    if condition == True:\n        newlist.append(expression)\n```\n:::\n\n\nSimilarly, there is a `dict` comprehension.\n\n::: {#cb17136b .cell execution_count=87}\n``` {.python .cell-code}\nnewdict = {key-expr: value-expr for item in iterable if condition == True}\n```\n:::\n\n\n::: {.callout-caution}\n`list`/`dict` comprehension is very powerful, and it is able to create very complex nested `list`/`dict` comprehension to squeeze some complicated codes into one line. It is highly recommended **NOT** to do so. \n\nThe purpose of `list`/`dict` comprehension is to improve readablity. Complicated nested `list`/`dict` comprehension actually makes your code hard to read. You can make `list`/`dict` comprehension with more than one layer only if you have a very good reason.\n:::\n\n\n\n::: {#exm-}\nConsider the following `dict`.\n\n::: {#afd5f38c .cell execution_count=88}\n``` {.python .cell-code}\nexample_dict = {'key1': 'value1',\n                'key2': 'value2',\n                'key3': 'value3'}\n```\n:::\n\n\n1. We want to go through the keys and generate a list whose elements are gotten by concatnating the keys and a fixed prefix `pre`. \n2. We want to go through the values and generate a list whose elements are gotten by concatnating the values and a fixed postfix `post`. \n\n\n::: {.callout-note collapse=\"true\"}\n## Solution\n\na. `.keys()` can give an iterator which helps us to loop through all the keys.\nb. For each key, we may add `pre` to the front of it, and then put the result into a `list`.\nc. This process is exactly what `list` comprehension can do.\n\nHere is the sample code.\n\n::: {#0b8442ae .cell execution_count=89}\n``` {.python .cell-code}\nprekeys = ['pre'+key for key in example_dict.keys()]\npostvalues = [value+'post' for value in example_dict.values()]\n```\n:::\n\n\n:::\n\n\n:::\n\n::: {#exm-}\nGiven a string `s=abcde`, create a `dict` that relates a letter with its next (and the next of `e` is back to `a`).\n\n::: {.callout-note collapse=\"true\"}\n## Solution\nThe problem actually creates a circle consisting of `a`, `b`, `c`, `d` and `e`. See the following diagram.  \n\n```{dot}\n//| fig-width: 4\n//| fig-height: 3\n\ndigraph G {\n  layout = neato;\n  overlap = false;\n  a [label=\"s[0]=a\"];\n  b [label=\"s[1]=b\"];\n  c [label=\"s[2]=c\"];\n  d [label=\"s[3]=d\"];\n  e [label=\"s[4]=e\"];\n  a -> b -> c -> d -> e -> a;\n}\n```\nIf we focus on the index, the transformation can be formulated as \"add 1 and then mod 5\". Therefore, every time when we get a letter `s[i]`, its next is `s[(i+1)%5]`. Then our code is as follows.\n\n::: {#510dc0f3 .cell execution_count=90}\n``` {.python .cell-code}\ns = 'abcde'\ntransform_dict = {}\nfor i in range(len(s)):\n    transform_dict[s[i]] = s[(i+1)%5]\n```\n:::\n\n\nNote that this process is exactly what a `dict` comprehension can do. Therefore we can simplify the above code as follows.\n\n::: {#8de82be9 .cell execution_count=91}\n``` {.python .cell-code}\ns = 'abcde'\ntransform_dict = {s[i]: s[(i+1)%5] for i in range(len(s))}\n```\n:::\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n## Examples\n\n### Monty Hall problem\n\n\nThe Monty Hall problem is a brain teaser, in the form of a probability puzzle, loosely based on the American television game show *Let's Make a Deal* and named after its original host, Monty Hall. The problem is stated as follows:\n\nSuppose you're on a game show, and you're given the choice of three doors: Behind one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what's behind the doors, opens another door, say No. 3, which has a goat. He then says to you, \"Do you want to pick door No. 2?\" Is it to your advantage to switch your choice?\n\nHere is a YouTube video of the Monty Hall problem.\n\n{{< video https://youtu.be/4Lb-6rxZxx0 >}}\n\n\nWe would like to use code to simulate this process. Here are the steps. \n\n\n::: {.callout-note collapse=\"true\"}\n## Setup\nWe use `1`, `2`, `3` to denote the three doors. We could put it in a list `doors = [1, 2, 3]`. Later after the game, we may record our result. There are only two possibilites: remains with the initial choice wins or switch to the new choice wins. We may record the result in a dictionary `results={'remain': 0, 'switch': 0}`, and update the corresponding key after one game.\n\n::: {#5c4716a0 .cell execution_count=92}\n``` {.python .cell-code}\ndoors = [1, 2, 3]\nresults = {'remain': 0, 'switch': 0}\n```\n:::\n\n\n:::\n\n\n::: {.callout-note collapse='true'}\n## 1. Put the car behind a door.\nWe randomly pick one door and put the car behind it. \n\n\"Randomly pick\" can be done by `random.choice()`. What it does is to take a sample chosen from the list. In our case, we would like to take a sample from `doors`. Therefore we want to use `random.choice(doors)`. The output is the door we randomly pick to put the car. So we set it to a variable `door_with_car` to remind us.\n\n::: {#f45fb768 .cell execution_count=93}\n``` {.python .cell-code}\nimport random\ndoor_with_car = random.choice(doors)\n```\n:::\n\n\nThis is a function in the package `random`. So to use it you should first `import random`. You may get more information from [the official document](https://docs.python.org/3/library/random.html#random.choice). \n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## 2. Make the initial choice.\nWe make our initial choice. We could also randomly pick one door as our initial choice. The code is similar to the previous one. \n\n::: {#71c0ba3b .cell execution_count=94}\n``` {.python .cell-code}\ninitial_choice = random.choice(doors)\n```\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## 3. The host opens another door.\nBased on the door with car and our inital choice, the host chooses a door without car to open. This door is denoted by `door_host_open`.\n\nThere are two possibility here:\n\n- If we haapen to pick the door with car, the host will randomly open one of the other two doors, since neither of them has car inside. In other words, we remove `door_with_car` from `doors`, and randomly pick one from the rest.\n- If we didn't pick the door with car, the car is in one of the other two doors, and the host has to open the other door. In other words, this door is the door that is neither `door_with_car` nor `initial_choice`.\n\nThe above analysis can be translated directly into the following code.\n\n::: {#5cd47167 .cell execution_count=95}\n``` {.python .cell-code}\nrest_doors = doors[:]\nif door_with_car == initial_choice:\n    rest_doors.remove(door_with_car)\n    door_host_open = random.choice(rest_doors)\nelif door_with_car != initial_choice:\n    rest_doors.remove(door_with_car)\n    rest_doors.remove(initial_choice)\n    door_host_open = random.choice(rest_doors)\n```\n:::\n\n\nNote that in this part, we directly remove elements from `doors`. Since we don't want to alter the original variable `doors`, and also `.remove()` works in-place, we make a copy of `doors` and call it `rest_doors` for us to remove doors. \n\nThe code `[:]` is used to make copies of list. This may be the fastest way to copy plain `list` in Python.\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## 4. Check the result.\nAfter the host opens `door_host_open`, two doors are left: our initial choice and the door unopened. The door unopened is actually the door that is neither our initial choice or the door host opens. It is the only element in `tmpdoors` after removing `initial_choice` and `door_host_open`. So we could directly get it by calling index `0`. The code is as follows. Note that we make another copy of `doors` at the beginning due to the same reason as the previous step.\n\n::: {#4c1da097 .cell execution_count=96}\n``` {.python .cell-code}\ntmpdoors = doors[:]\ntmpdoors.remove(door_host_open)\ntmpdoors.remove(initial_choice)\ndoor_unopened = tmpdoors[0]\n```\n:::\n\n\nThen we could start the check the result. \n\n- If `door_with_car` equals `initial_choice`, remaining with the initial choice wins. \n- If `door_with_car` equals `door_unopened`, switching to the new door wins.\nWe could update the result dictionary accordingly.\n\n::: {#9d386e88 .cell execution_count=97}\n``` {.python .cell-code}\nif door_with_car == initial_choice:\n    winner = 'remain'\nelif door_with_car == door_unopened:\n    winner = 'switch'\n\nresults[winner] = results[winner] + 1\n```\n:::\n\n\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n## Put things together\nWe now put the above steps together.\n\n::: {#5607ce69 .cell execution_count=98}\n``` {.python .cell-code}\nimport random\ndoors = [1, 2, 3]\nresults = {'remain': 0, 'switch': 0}\n\ndoor_with_car = random.choice(doors)\ninitial_choice = random.choice(doors)\n\nrest_doors = doors[:]\nif door_with_car == initial_choice:\n    rest_doors.remove(door_with_car)\n    door_host_open = random.choice(rest_doors)\nelif door_with_car != initial_choice:\n    rest_doors.remove(door_with_car)\n    rest_doors.remove(initial_choice)\n    door_host_open = random.choice(rest_doors)\n\ntmpdoors = doors[:]\ntmpdoors.remove(door_host_open)\ntmpdoors.remove(initial_choice)\ndoor_unopened = tmpdoors[0]\n\nif door_with_car == initial_choice:\n    winner = 'remain'\nelif door_with_car == door_unopened:\n    winner = 'switch'\n\nresults[winner] = results[winner] + 1\n```\n:::\n\n\nThe code can be simplified in multiple ways. However here I would like to show how to translate something directly into codes. So I will just keep it as it is.\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Wrapped in a function\nThe above game process can be wrapped in a function.\n\n::: {#cb32f23d .cell execution_count=99}\n``` {.python .cell-code}\nimport random\n\ndef MontyHall():\n    doors = [1, 2, 3]\n\n    door_with_car = random.choice(doors)\n    initial_choice = random.choice(doors)\n\n    rest_doors = doors[:]\n    if door_with_car == initial_choice:\n        rest_doors.remove(door_with_car)\n        door_host_open = random.choice(rest_doors)\n    elif door_with_car != initial_choice:\n        rest_doors.remove(door_with_car)\n        rest_doors.remove(initial_choice)\n        door_host_open = random.choice(rest_doors)\n\n    tmpdoors = doors[:]\n    tmpdoors.remove(door_host_open)\n    tmpdoors.remove(initial_choice)\n    door_unopened = tmpdoors[0]\n\n    if door_with_car == initial_choice:\n        winner = 'remain'\n    elif door_with_car == door_unopened:\n        winner = 'switch'\n    return winner\n```\n:::\n\n\n:::\n\nNow we may play the game by calling the function `MontyHall()`. The return value is the winner, which can be used to update `results`.\n\n::: {#2c89e873 .cell execution_count=100}\n``` {.python .cell-code}\nresults = {'remain': 0, 'switch': 0}\nwinner = MontyHall()\nresults[winner] = results[winner] + 1\n```\n:::\n\n\nThen we may play the game multiple times, and see which strategy wins more. The following is the result of 100 games.\n\n::: {#0cd0b9e7 .cell execution_count=101}\n``` {.python .cell-code}\nresults = {'remain': 0, 'switch': 0}\n\nfor i in range(100):\n    winner = MontyHall()\n    results[winner] = results[winner] + 1\n\nresults\n```\n\n::: {.cell-output .cell-output-display execution_count=91}\n```\n{'remain': 31, 'switch': 69}\n```\n:::\n:::\n\n\nFrom this result, you may guess that switch might be the better strategy.\n\n\n### `N`-door Monty Hall problem {#sec-ndoormh}\n\n\nThe Monty Hall problem can be modified to `N` doors. The host will open `N-2` doors which don't have the car behind, and only leave one door left for us to choose. What will you choose?\n\nWe only need to modify our codes a little bit for the change. You may bring the idea \"there are `N` doors\" to the process mentioned above to see what should be modified. However when writing the code, you may still set `N=3` and change it later after you finish.\n\n::: {.callout-note collapse=\"true\"}\n## 1. Change `doors`\n<!-- The initial setup for `doors` becomes `list(range(1, N+1))`. -->\n\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## 2. The host opens multiple doors\n<!-- The major change is that now the host has to open `N-2` to only leave one unopened door for us. In other words, during Step 3, we need to take a length `N-2` sample for the host to open. \n\nUsing the package `random`, to take a length `N-2` sample, we could use the function `random.sample(L, N-2)`. Please go to [the official document](https://docs.python.org/3/library/random.html#random.sample) for more information. -->\n\n\n\n<!-- Note that the logic of the last line is similar to `N=3` case. The host has to open `N-2` doors that are neither `door_with_car` nor `initial_choice`. If the two doors are different, the host has to open all the rest doors. That's why `door_host_open = rest_doors`. -->\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## 3. Remove multiple `door_host_open`\n<!-- Because now the host opens more than 1 door, `door_host_open` is now a list, which contains all the doors opened by the host. Then in Step 4 when we remove `door_host_open`, we have to run a `for` loop to remove those doors one by one. -->\n\n\n\n<!-- Then the codes are  -->\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Put things together\n<!-- Here is the updated function. -->\n\n\n\n<!-- Note that we set the default value of `N` is `3`. So if we call `MontyHall()` it will run the `3`-door version.  -->\n:::\n\nNow we can start to play the game. We may test our code by using the default `N` which is `3`.\n\n::: {#635587b4 .cell execution_count=106}\n``` {.python .cell-code}\nresults = {'remain': 0, 'switch': 0}\n\nfor i in range(100):\n    winner = MontyHall()\n    results[winner] = results[winner] + 1\n\nresults\n```\n:::\n\n\n```\n{'remain': 34, 'switch': 66}\n```\n\nYou will see that we get a similar result as our previous version.\n\nNow we will try `10`-door version.\n\n::: {#928abfd3 .cell execution_count=107}\n``` {.python .cell-code}\nresults = {'remain': 0, 'switch': 0}\n\nfor i in range(100):\n    winner = MontyHall(10)\n    results[winner] = results[winner] + 1\n\nresults\n```\n:::\n\n\n```\n{'remain': 9, 'switch': 91}\n```\n\nThe result also shows that switch is a better strategy. This is the simulation approach for this classic problem. You may compare it with theorical calculations using Probability theory.\n\n\n\n\n### Color the Gnomic data\n\nWe can use ASCII color codes in the string to change the color of strings. As an example, `\\033[91m` is for red and `\\033[94m` is for blue. See the following example.\n\n::: {#05aa75bb .cell execution_count=108}\n``` {.python .cell-code}\nprint('\\033[91m'+'red'+'\\033[92m'+'green'+'\\033[94m'+'blue'+'\\033[93m'+'yellow')\n```\n:::\n\n\nThis example works in IPython console or Jupyter notebook. \n\n\nConsider an (incomplete) Gnomic data given below which is represented by a long sequence of `A`, `C`, `T` and `G`. Please color it using ASCII color codes.\n\n::: {#a43a764a .cell execution_count=109}\n``` {.python .cell-code}\ngnomicdata = 'TCGATCTCTTGTAGATCTGTTCTCTAAACGAACTTTAAAATCTGTGTGGCTGTCACTCGG'\\\n             'CTGCATGCTTAGTGCACTCACGCAGTATAATTAATAACTAATTACTGTCGTTGACAGGAC'\\\n             'ACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTGTTGCAGCCGATC'\\\n             'ATCAGCACATCTAGGTTTTGTCCGGGTGTGACCGAAAGGTAAGATGGAGAGCCTTGTCCC'\\\n             'TGGTTTCAACGAGAAAACACACGTCCAACTCAGTTTGCCTGTTTTACAGGTTCGCGACGT'\\\n             'GCTCGTACGTGGCTTTGGAGACTCCGTGGAGGAGGTCTTATCAGAGGCACGTCAACATCT'\\\n             'TAAAGATGGCACTTGTGGCTTAGTAGAAGTTGAAAAAGGCGTTTTGCCTCAACTTGAACA'\\\n             'GCCCTATGTGTTCATCAAACGTTCGGATGCTCGAACTGCACCTCATGGTCATGTTATGGT'\\\n             'TGAGCTGGTAGCAGAACTCGAAGGCATTCAGTACGGTCGTAGTGGTGAGACACTTGGTGT'\\\n             'CCTTGTCCCTCATGTGGGCGAAATACCAGTGGCTTACCGCAAGGTTCTTCTTCGTAAGAA'\\\n             'CGGTAATAAAGGAGCTGGTGGCCATAGTTACGGCGCCGATCTAAAGTCATTTGACTTAGG'\\\n             'CGACGAGCTTGGCACTGATCCTTATGAAGATTTTCAAGAAAACTGGAACACTAAACATAG'\n```\n:::\n\n\nThe way to color `A` as a red `A` is to change the character into `\\033[91mA`. Then using in IPython console or Jupyter notebook after you print it, you can see a red `A`. Therefore the core idea to solve this problem is to replace `A` in the string by `\\033[91mA`, etc..\n\nThere are multiple ways to implement this idea.\n\n::: {.callout-note collapse=\"true\"}\n## `if-elif-else`\nWe loop through the whole string. Every time when we get an `A`, we replace it with `\\033[91mA`. The same applies to `C`, `T` and `G`.\n\nTo implement this idea, we actually make another list `newlist`. Every time we read `A` from `gnomicdata`, we add `033[91mA` to the `newlist`. Then at the end we could combine all strings in `newlist` to get the string we need.\n\nHere is the code.\n\n::: {#4084b7fd .cell execution_count=110}\n``` {.python .cell-code}\nnewlist = []\nfor letter in gnomicdata:\n    if letter == 'A':\n        newlist.append('\\033[91mA')\n    elif letter == 'C':\n        newlist.append('\\033[92mC')\n    elif letter == 'T':\n        newlist.append('\\033[93mT')\n    elif letter == 'G':\n        newlist.append('\\033[94mG')\ngnomicstring = ''.join(newlist)\n```\n:::\n\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Upgrade using `dict`\nIn the previous method, the big `if...elif...` doesn't look very good. We could use `dict` to simplify the code.\n\nThe key idea of the `if...elif...` statement is to make a relation between `A` and `\\033[91mA`, etc.. This is exactly what a `dict` can do.\n\nHere is the sample code.\n\n::: {#6a7d332c .cell execution_count=111}\n``` {.python .cell-code}\ncolor_pattern = {\n    'A': '\\033[91mA',\n    'C': '\\033[92mC',\n    'T': '\\033[93mT',\n    'G': '\\033[94mG',\n}\n\nnewlist = []\nfor letter in gnomicdata:\n    newlist.append(color_pattern[letter])\ngnomicstring = ''.join(newlist)\n```\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Upgrade using `list` comprehension\nIn the previous method, there is a `new list, for...list.append()` structure. This is exactly what `list` compreshension can do.\n\nHere is the sample code.\n\n::: {#3719d398 .cell execution_count=112}\n``` {.python .cell-code}\ncolor_pattern = {\n    'A': '\\033[91mA',\n    'C': '\\033[92mC',\n    'T': '\\033[93mT',\n    'G': '\\033[94mG',\n}\n\ngnomicstring = ''.join([color_pattern[letter] for letter in gnomicdata])\n```\n:::\n\n\nThe last piece of code is the best of the three. On the one side it is more condense and easy to read. On the other side, it is actually split into two pieces explicitly: the sytle part (`color_pattern`) and the code part (`gnomicstring`). The code part only controls changing colors, but the colors of the letters are controlled by the style part. This split make the code easier to maintain.\n:::\n\n\n## Exercises\nMost problems are based on @Sha2017, @You2020, @Swe2020, @McK2017 and @Klo2021.\n\n\n::: {#exr-}\n## Indentation\nPlease tell the differences between the following codes. Write your answers in the Markdown cells.\n\n::: {#10f87eba .cell execution_count=113}\n``` {.python .cell-code}\nfor i in range(5):\n    print('Hello world!')\nprint('Hello world!')\n```\n:::\n\n\n::: {#615b1190 .cell execution_count=114}\n``` {.python .cell-code}\nfor i in range(5):\n    print('Hello world!')\n    print('Hello world!')\n```\n:::\n\n\n::: {#4ea054a2 .cell execution_count=115}\n``` {.python .cell-code}\nfor i in range(5):\nprint('Hello world!')\nprint('Hello world!')\n```\n:::\n\n\n::: {#f2284ca2 .cell execution_count=116}\n``` {.python .cell-code}\nfor i in range(5):\n    pass\nprint('Hello world!')\nprint('Hello world!')\n```\n:::\n\n\n:::\n\n\n\n\n::: {#exr-}\n## Play with built-in data types\n\nPlease first guess the results of all expressions below, and then run them to check your answers.\n\n::: {#9a098316 .cell execution_count=117}\n``` {.python .cell-code}\nTrue and True\nTrue or True\nFalse and True\n(1+1>2) or (1-1<1)\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\n## `==` vs `is`\nPlease explain what happens below.\n\n::: {#0e023554 .cell execution_count=118}\n``` {.python .cell-code}\na = 1\nb = 1.0\ntype(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=100}\n```\nint\n```\n:::\n:::\n\n\n::: {#6fae36b3 .cell execution_count=119}\n``` {.python .cell-code}\ntype(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=101}\n```\nfloat\n```\n:::\n:::\n\n\n::: {#2f99d605 .cell execution_count=120}\n``` {.python .cell-code}\na == b\n```\n\n::: {.cell-output .cell-output-display execution_count=102}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#9af42a8f .cell execution_count=121}\n``` {.python .cell-code}\na is b\n```\n\n::: {.cell-output .cell-output-display execution_count=103}\n```\nFalse\n```\n:::\n:::\n\n\n:::\n\n\n::: {#exr-}\n## Play with strings\n\n1. Please use `.format()` to generate the following sentences.\n\n::: {#00ce6b9d .cell execution_count=122}\n``` {.python .cell-code}\n\"The answer to this question is 1. If you got 2, you are wrong.\"\n\"The answer to this question is 2. If you got x, you are wrong.\"\n\"The answer to this question is True. If you got 23, you are wrong.\"\n\"The answer to this question is 4. If you got 32, you are wrong.\"\n```\n:::\n\n\n2. Please use `.format()` and `for` loop to generate the following sentence and replace the number `1` inside with all positive odd numbers under `10`.\n\n::: {#3c5c6234 .cell execution_count=123}\n``` {.python .cell-code}\n\"I like 1 most among all numbers.\"\n```\n:::\n\n\n:::\n\n\n\n\n::: {#exr-}\n# Toss a coin\n\n1. Please write a function `tossacoin()` to simulate tossing a coin. The output is `H` or `T`, and each call of the function has a 50/50 chance of getting `H` or `T`. Please use the following code to get a random number between `0` and `1`.\n\n::: {#0453ed70 .cell execution_count=124}\n``` {.python .cell-code}\nimport numpy as np\nnp.random.rand()\n```\n:::\n\n\n2. Please simulate tossing a coin 20 times, and print out the results.\n3. The coin might be uneven. In this case the probability to get `H` is no longer `0.5`. We would like to use an argument `p` to represent the probability of getting `H`. Please upgrade your function `tossacoin()` to be compatible with uneven coins. Then please simulate tossing a coin  (with `p=0.1`, for example) 20 times, and print out the results.\n4. Tossing a coin 100 times, and record the results in a `list`.\n\n:::\n\n\n\n::: {#exr-}\n## `split` and `join`\n\n1. Please get the list of words `wordlist` of the following sentence.\n\n::: {#4bc7c68b .cell execution_count=125}\n``` {.python .cell-code}\nsentence = 'This is an example of a sentence that I expect you to split.'\n```\n:::\n\n\n2. Please combine the `wordlist` gotten from part 1 to get a string `newsentence`, where all spaces are replaced by `\\n`.\n\n:::\n\n\n::: {#exr-}\n## List reference\n\nPlease finish the following tasks.\n\n1. Given the list `a`, make a new reference `b` to `a`. Update the first entry in `b` to be `0`. What happened to the first entry in `a`? Explain your answer in a text block.\n\n2. Given the list `a`, make a new copy `b` of the list `a` using the function `list`. Update the first entry in `b` to be `0`. What happened to the first entry in `a`? Explain your answer in a text block. \n:::\n\n\n\n::: {#exr-}\nPlease tell the differences of the following objects.\n\n1. `[1, 2, 3, 4, 5, 6]`\n2. `[[1, 2], [3, 4], [5, 6]]`\n3. `{1: 2, 3: 4, 5: 6}`\n4. `{1: [2], 3: [4], 5: [6]}`\n5. `[{1: 2}, {3: 4}, {5: 6}]`\n:::\n\n\n::: {#exr-}\n## List comprehension\n\n1. Given a list of numbers, use list comprehension to remove all odd numbers from the list:\n\n::: {#82d24fe4 .cell execution_count=126}\n``` {.python .cell-code}\nnumbers = [3,5,45,97,32,22,10,19,39,43]\n```\n:::\n\n\n2. Use list comprehension to find all of the numbers from 1-1000 that are divisible by 7.\n3. Use list comprehension to get the index and the value as a tuple for items in the list `['hi', 4, 8.99, 'apple', ('t,b', 'n')]`. Result would look like `[(index, value), (index, value), ...]`.\n4. Use list comprehension to find the common numbers in two lists (without using a tuple or set) `list_a = [1, 2, 3, 4]`, `list_b = [2, 3, 4, 5]`.\n:::\n\n\n::: {#exr-}\n\n1. Given a string, use list comprehension to count the number of spaces in it.\n2. Write a function that counts the number of spaces in a string.\n:::\n\n::: {#exr-}\n## Probability\nCompute the probability that two people out of 23 share the same birthday. The math formula for this is \n$$1-\\frac{365!/(365-23)!}{365^{23}}=1-\\frac{365}{365}\\cdot\\frac{365-1}{365}\\cdot\\frac{365-2}{365}\\cdot\\ldots\\cdot\\frac{365-22}{365}.$$\n\n1. To directly use the formula we have to use a high performance math package, e.g. `math`. Please use `math.factorial()` to compute the left hand side of the above formula. You should `import math` to use the function since it is in the `math` package.\n\n2. Please use the right hand side of the above formula to compute the probability using the following steps.\n    a. Please use the list comprehension to create a list $\\left[\\frac{365}{365},\\frac{365-1}{365},\\frac{365-2}{365},\\ldots,\\frac{365-22}{365}\\right]$. \n    b. Use `math.prod()` to compute the product of elements of the above list. You should `import math` to use the function since it is in the `math` package.\n    c. Compute the probability by finishing the formula.\n\n3. Please use `time` to test which method mentioned above is faster.\n:::\n\n\n\n::: {#exr-}\n## Determine the indefinite article\nPlease finish the following tasks.\n\n1. Please construct a list `aeiou` that contains all vowels.\n2. Given a word `word`, we would like to find the indefinite article `article` before `word`. (Hint: the article should be `an` if the first character of `word` is a vowel, and `a` if not.)\n:::\n<details>\n<summary> Click for Hint.</summary>\n::: {.solution}\nConsider `in`, `.lower()` and `if` structure.\n:::\n</details>\n\n\n\n::: {#exr-}\n## File names\n\n1. Please use Python code to generate the following list of file names: `file0.txt`, `file1.txt`, `file2.txt`, ... `file9.txt`. \n2. Please use Python code to generate the following list of file names: `file0.txt`, `file1.txt`, `file2.txt`, ... `file10.txt`, `file11.txt`, ..., `file99.txt`, `file100.txt`. \n3. Please use Python code to generate the following list of file names: `file000.txt`, `file001.txt`, `file002.txt`, ... `file100.txt`. You may consider `.zfill()` to fill the zeros.\n:::\n\n::: {#exr-}\n## Datetime and files names\nWe would like to write a program to quickly generate many files. (For example, we want to take random samples multiple times and we want to keep all our samples. Another example is to generate AI pictures.) Every time we run the code, many files will be generated. We hope to store all files generated and organize them in a neat way. To achieve this, one way is to create a subfolder for each run and store all files generated during that run in the particular subfolder. Since we would like to make it fast, the real point of this task is to find a way to automatically generate the filenames for the files generated and the folder names for the subfolders generated. \n\nOne way to automatically generate file names and folder names is to use the date and the time when the code is run. Please check `datetime` package for getting and formatting date/time, and `os` packages for playing with files and folders. Here are some suggested steps.\n\n1. Use `datetime` packages to get the current date and time. You may read [this article](https://docs.python.org/3/library/datetime.html) to learn how to use `datetime` package.\n2. Use the current date and time to form two strings `currentdate` and `currenttime`.\n3. Assume that we would like to generate 100 files. Then please generate a list of strings that each one is string that represents a path with folder `currentdate`, subfolder `currenttime` and file name `X.txt` where `X` is a number from `0` to `99`.\n:::\n<details>\n<summary>Click for Hint.</summary>\nYou may try `datetime.datetime.now()` and `.strftime()` method for the `datetime` object.\n</details>\n\n\n\n\n::: {#exr-}\n## Caesar cipher\nIn cryptography, a *Caesar cipher* is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, `D` would be replaced by `A`, `E` would become `B`, and so on. The method is named after Julius Caesar, who used it in his private correspondence.\n\nPlease write two functions to implement Caesar cipher and decipher. To make things easier, we implement the following two rules.\n\n1. Spaces, `,`, numbers or other non-alphabic letters will NOT be changed.\n2. Upper case and lower case will NOT be changed.\n\nNote that you may add the number of shifts as a parameter in your function.\n:::\n\n\n\n::: {#exr-}\n## `sorted`\nPlease read through the Key Funtions section in this [article](https://docs.python.org/3/howto/sorting.html#key-functions), and sort the following two lists.\n\n1. Sort `list1 = [[11,2,3], [2, 3, 1], [5,-1, 2], [2, 3,-8]]` according to the sum of each list.\n\n2. Sort `list2 = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4},{'a': 5, 'b': 2}]` according to the `b` value of each dictionary.\n:::\n\n\n\n\n::: {#exr-fantasyinventorycode}\n## Fantasy Game Inventory\n\nYou are creating a fantasy video game. The data structure to model the player’s inventory will be a dictionary where the keys are string values describing the item in the inventory and the value is an integer value detailing how many of that item the player has. For example, the dictionary value `{'rope': 1, 'torch': 6, 'gold coin': 42, 'dagger': 1, 'arrow': 12}` means the player has 1 rope, 6 torches, 42 gold coins, and so on.\n\n1. Write some code to take any possible `inventory` and display it like the following. Note that the order of items doesn't matter. The purpose of this exercise is to read information from a `dict` and translate it into a format you need.\n\n::: {#9f01cdd0 .cell execution_count=127}\n``` {.python .cell-code}\nInventory:\n12 arrow\n42 gold coin\n1 rope\n6 torch\n1 dagger\nTotal number of items: 62\n```\n:::\n\n\n2. Write a function named `displayInventory()` that would take any possible `inventory` and display it in the above way.\n:::\n\n\n\n::: {#exr-ndoormontyhall}\n# `N`-door Monty Hall problem\nPlease finish the function `MontyHall()` for the `N`-door Monty Hall problem described in @sec-ndoormh.\n:::\n\n",
    "supporting": [
      "intro_files"
    ],
    "filters": [],
    "includes": {}
  }
}