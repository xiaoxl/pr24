{
  "hash": "3d734141108b611e8f61b3bd6ebd99e8",
  "result": {
    "engine": "jupyter",
    "markdown": "# Classes/Packages for Python\n\n\n\n\n\n\n\n## Classes\nA class is an abstract structure that can be used to hold both variables and functions. Variables in a class are called *attributes*, and functions in a class are called *methods*.\n\nA class is defined in the following way.\n\n::: {#f507a99b .cell execution_count=1}\n``` {.python .cell-code}\nclass Circle:\n    def __init__(self, radius=1):\n        self.radius = radius\n    \n    def area(self):\n        return self.radius**2*3.14 \n```\n:::\n\n\nIn this example, we define a class `Circle`, which represents a circle. There is one attribute `radius`, and one method `area`. When define a cirlce, we need to specify its radius, and we could use the method `area` to compute the area of the circle.\n\n::: {#260b7b57 .cell execution_count=2}\n``` {.python .cell-code}\ncir1 = Circle()\ncir2 = Circle(radius=5)\n\ncir1.area()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n3.14\n```\n:::\n:::\n\n\n::: {#78209143 .cell execution_count=3}\n``` {.python .cell-code}\ncir2.area()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n78.5\n```\n:::\n:::\n\n\nHere we define two circles. The first circle `cir1` is of radius `1`. This `1` comes from the default value. Check the definition of `Circle.__init__()`. \n\nThe second circle `cir2` is of radius `5`, and this number is specified when we initialize the `Circle` instance.\n\nThen we compute the areas of these two circles by calling the `area()` method. You can also use `cir1.radius` to get access the radius of the circle. The syntax difference between attributes and methods is the `()` at the end.\n\n### `self`\nYou may notice the `self` variable in the definition of the classes. The `self` is used to refered to the class its. When you want to get access to the class attributes or the class methods, you may use `self`.\n\nTake the code as an example. \n\n::: {#f50281b8 .cell execution_count=4}\n``` {.python .cell-code}\nclass Circle:\n    def __init__(self, radius=1):\n        self.radius = radius\n```\n:::\n\n\nIn the `__init__` function, there are two `radius`.\n\n1. `radius` is the local variable that is used by the function. It is also the input argument.\n2. `self.radius` is the class attribute, that is shared by all class methods. For example, we may add another class method to the class `Circle`.\n\n::: {#3232e135 .cell execution_count=5}\n``` {.python .cell-code}\nclass Circle:\n    def __init__(self, radius=1):\n        self.radius = radius\n    \n    def area(self):\n        return self.radius**2*3.14 \n    \n    def perimeter(self):\n        return self.radius*3.14*2\n```\n:::\n\n\nBoth `area()` and `perimeter()` use the same `self.radius`.\n\n\n:::{.callout-note}\nClass attributes are defined in the `__init__()` function. \n:::\n\n\n\n### A design example\nAssume that we live in a world without Pandas, and we would like to design a table object. Then what do we need?\n\nA table should have multiple rows and multiple columns. We should be able to get access entries by columns and row index. We should also be able to display the table by using the `print` funciton.\n\n\n::: {.callout-note}\nThe `.__str__()` method will be called when you try to `print` the object. If you don't explicitly override it, the type of the object will be shown.\n:::\n\nTherefore we may write the following class.\n\n::: {#5b89beae .cell execution_count=6}\n``` {.python .cell-code}\nclass myTableClass():\n    def __init__(self, listoflist=None):\n        if listoflist is None:\n            listoflist = [[]]\n        self.nrows = len(listoflist)\n        self.ncols = len(listoflist[0])\n        self.data = listoflist\n        self.shape = (self.nrows, self.ncols)\n    \n    def get(self, i, j):\n        return self.data[i][j]\n\n    def __str__(self):\n        tmp = [' '.join([str(x) for x in row]) for row in self.data]\n        return '\\n'.join(tmp)\n```\n:::\n\n\nThis is a very brief table object. We may add more things to it. For example, we could talk about column names.\n\n::: {#5daa9c4a .cell execution_count=7}\n``` {.python .cell-code}\nclass myTableClass():\n    def __init__(self, listoflist=None, columns=None):\n        if listoflist is None:\n            listoflist = [[]]\n        if columns is None:\n            columns = list()\n        self.nrows = len(listoflist)\n        self.ncols = len(listoflist[0])\n        self.data = listoflist\n        self.shape = (self.nrows, self.ncols)\n        self.columns = columns\n    \n    def get(self, i, j):\n        return self.data[i][j]\n\n    def rename(self, columns=None):\n        if columns is not None:\n            self.columns = columns\n\n    def __str__(self):\n        tmp = [' '.join([str(x) for x in row]) for row in self.data]\n        if len(self.columns) != 0:\n            tmp.insert(0, self.columns)\n        return '\\n'.join(tmp)\n```\n:::\n\n\n::: {.callout-note}\nIn Jupyter notebook or similar environment, we might directly call `df` to show a DataFrame and the shown DataFrame is rendered very pretty. This is due to the `IPython.display.display()` method, and is part of IPython console components.  \n:::\n\n## Inheritance\n\nOne of the most important feature of classes is inheritance. Attributes and methods can be passed from parents to children, and child classes can override those attributes and methods if needed.\n\nFor example, we would like to first write a `people` class.\n\n::: {#5663e8ba .cell execution_count=8}\n``` {.python .cell-code}\nclass people():\n    def __init__(self, name='default', age=20):\n        self.name = name\n        self.age = age\n\n    def eat(self):\n        print('eat something.')\n```\n:::\n\n\nThis `people` class defines a people who can eat. Then using this `people` class, we could build a children class: `student`.\n\n::: {#e3f0a79b .cell execution_count=9}\n``` {.python .cell-code}\nclass student(people):\n    pass\n```\n:::\n\n\n::: {#58901845 .cell execution_count=10}\n``` {.python .cell-code}\nstu1 = student('name1', 10)\nstu1.eat()\nstu1.name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neat something.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n'name1'\n```\n:::\n:::\n\n\n::: {#917b063e .cell execution_count=11}\n``` {.python .cell-code}\ntype(stu1)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n__main__.student\n```\n:::\n:::\n\n\nNow you can see that this `stu1` is a `student`, but it has all attributes and methods as a `people`. However at current stage `student` and `people` are exactly the same since we don't have any new codes for `student`. Let us improve it a little bit.\n\n::: {#5f965ed7 .cell execution_count=12}\n``` {.python .cell-code}\nclass student(people):\n    def __init__(self, name='default', age=20, grade=1):\n        super().__init__(name, age)\n        self.grade = grade\n\n    def eat(self):\n        print('eat in the cafe.')\n\nstu1 = student('name1', 10)\nstu1.eat()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\neat in the cafe.\n```\n:::\n:::\n\n\nNow `student` class override the `eat()` method from `people`. If someone is a `student`, he or she will eat in the cafe instead of just eat something.\n\nIn addition, you may also notice that the `__init__()` constructor function is also overriden. The first part is `super().__init__(name, age)` which is just call the `people`'s constructor function. The second part is new in `student`, that we add a new attribute `grade` to it. Now `stu1` have attributes from `people` and the new attribute defined in `student`.\n\n::: {#40e51ea2 .cell execution_count=13}\n``` {.python .cell-code}\nstu1.name, stu1.age\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n('name1', 10)\n```\n:::\n:::\n\n\n::: {#24399454 .cell execution_count=14}\n``` {.python .cell-code}\nstu1.grade\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n1\n```\n:::\n:::\n\n\n## packages / modules\n\nMain reference is [RealPython](https://realpython.com/python-modules-packages/) and @Beu2022.\n\n### `import`\n\nIn most cases we won't only write one single Python file. If we want to use codes from other files, we need to `import`.\n\n- If both files are in the same folder, e.g. `file1.py` and `file2.py`, you may just put `import file2` in `file1.py`, and use `file2.myfunction()` to call functions or variables defined in `file2.py`.\n- If both files are in the same folder, and you just want to use one function from `file1.py` in `file2.py`, you may `from file1 import myfunction()`, and then directly write `myfunction()` in `file2.py`.\n\n\n::: {#exm-}\nThis is from `file1.py`.\n\n::: {#9030473e .cell execution_count=15}\n``` {.python .cell-code}\ns = \"This is from file1.py.\"\na = [100, 200, 300]\nprint(s)\n\ndef foo(arg):\n    print(f'arg = {arg}')\n\nclass Foo:\n    pass\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is from file1.py.\n```\n:::\n:::\n\n\nIn `file2.py`, we could get access to these variables and functions and classes as follows.\n\n::: {#5c75e684 .cell execution_count=16}\n``` {.python .cell-code}\nimport file1\nfile1.s\n```\n:::\n\n\n::: {#dc36bf4a .cell execution_count=17}\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n'This is from file1.py.'\n```\n:::\n:::\n\n\n::: {#03e0c1a8 .cell execution_count=18}\n``` {.python .cell-code}\nfile1.a\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n[100, 200, 300]\n```\n:::\n:::\n\n\n::: {#aa1a6648 .cell execution_count=19}\n``` {.python .cell-code}\nfile1.foo(file1.a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narg = [100, 200, 300]\n```\n:::\n:::\n\n\n::: {#661c3442 .cell execution_count=20}\n``` {.python .cell-code}\nfile1.Foo()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n<assests.codes.file1.Foo at 0x171ff8fbe50>\n```\n:::\n:::\n\n\n:::\n\n::: {.callout-note}\nAn alternative way is to use `from <module> import <names>` to directly use the names without the `file1.` prefix. \n:::\n\nPlease see the following Example to get a feel about how namespace works.\n\n\n::: {#exm-}\n\n::: {#c3b77359 .cell execution_count=21}\n``` {.python .cell-code}\ns = 'foo'\na = ['foo', 'bar', 'baz']\n\nfrom file1 import s as string, a as alist\ns\n```\n:::\n\n\n::: {#b217e124 .cell execution_count=22}\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n'foo'\n```\n:::\n:::\n\n\n::: {#8e991f2b .cell execution_count=23}\n``` {.python .cell-code}\nstring\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n'This is from file1.py.'\n```\n:::\n:::\n\n\n::: {#0e262225 .cell execution_count=24}\n``` {.python .cell-code}\na\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n['foo', 'bar', 'baz']\n```\n:::\n:::\n\n\n::: {#c340ee30 .cell execution_count=25}\n``` {.python .cell-code}\nalist\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n[100, 200, 300]\n```\n:::\n:::\n\n\n:::\n\nWe may use `dir()` to look at all objects in the current namespace.\n\n### `__name__`\n`__name__` is a variable to tell you want is the current active namespace. See the following example.\n\n::: {#exm-}\n\n::: {#3f369076 .cell execution_count=26}\n``` {.python .cell-code}\nimport file1\nfile1.__name__\n```\n:::\n\n\n::: {#2e46af92 .cell execution_count=27}\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n'assests.codes.file1'\n```\n:::\n:::\n\n\nThe result `file1` means that the codes in `file1.py` are now treated as a package and are imported into other files.\n\n::: {#8fe35a4f .cell execution_count=28}\n``` {.python .cell-code}\n__name__\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n'__main__'\n```\n:::\n:::\n\n\nThe result `__main__` means that the codes we are writing now are treated as in the \"active\" enviroment.\n\n\nYou may see the following codes in a lot of places.\n\n::: {#7198e8b8 .cell execution_count=29}\n``` {.python .cell-code}\nif __name__ == '__main__':\n    pass\n```\n:::\n\n\nIt means that the following codes will only be run in the \"active\" mode. If you import the codes as a package, these part of codes won't be run.\n\n:::\n\n### Packages\nPacages is a way to group and organize mutliple modules. It allow for a hierachical structuring of the module namespace using dot notation.\n\nCreating a package is straightforward, since it makes use of the operating system's inherent hierarchical file structure.\n\nPython defines two types of packages, regular packages and namespace packages. The above package is the regular one. Namespace packages allow codes are spread among different folders. We won't talk about it in this course.\n\nTo create a regular package, what you need to do is to organize the files in suitable folders, and then add an `__init__.py` in each folder. The file can be empty, or you could add any initialization codes for the package which is represented by the folder.\n\n\n:::{.callout-note}\nIn the past `__init__.py` is required for a package. After Python 3.3 the namespace package is introduced, the `__init__.py` is not required (but recommended) for regular packages, and cannot be used for namespace packages. \n:::\n\nLet us put the previous `file1.py` and `file2.py` into subfolder `assests/codes/`. To make it into a package `assests` and a subpackage `codes`, we need to put `__init__.py` in each folder. \n\n::: {#a711f25b .cell execution_count=30}\n``` {.python .cell-code}\nimport assests.codes.file1 as f1\nf1.s\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n'This is from file1.py.'\n```\n:::\n:::\n\n\n## Exercieses\n\nProblems are based on @Swe2020.\n\n::: {#exr-}\n## Heron's formula\nConsider a triangle whose sides are $a$, $b$ and $c$. Heron's formula states that the area of this triangle is \n$$\\sqrt{s(s−a)(s−b)(s−c)}\\quad\\text{ where } s=\\frac12(a+b+c).$$\n\nPlease write a function that given three points computes the area of the triangle with vertices being the given points. The input is required to be a `list` of three `tuple`s, where each `tuple` contains two numbers representing the 2d-coordinate of a point.\n:::\n\n\n\n::: {#exr-}\n## array\nWrite a function to reverse an 1D NumPy array (first element becomes last).\n:::\n\n\n\n\n::: {#exr-}\n## Compare two `numpy` arraies\nConsider two `numpy` arraies `x` and `y`. Compare them entry by entry. We would like to know how many are the same.\n\nWrite a function that the inputs are `x` and `y`, and the output is the number of the same numbers.\n:::\n\n\n\n\n\n\n::: {#exr-}\n## Comma Code\nSay you have a list value like this: `spam = ['apples', 'bananas', 'tofu', 'cats']`. \n\nWrite a function that takes a list value as an argument and returns a string with all the items separated by a comma and a space, with `and` inserted before the last item. For example, passing the previous `spam` list to the function would return 'apples, bananas, tofu, and cats'. But your function should be able to work with any list value passed to it. Be sure to test the case where an empty list `[]` is passed to your function.\n:::\n\n\n\n\n::: {#exr-}\nCreate a Car class with two instance attributes:\n\n1. `.color`, which stores the name of the car’s color as a string.\n2. `.mileage`, which stores the number of miles on the car as an integer.\n\nThen instantiate two Car objects — a blue car with 20,000 miles and a red car with 30,000 miles — and print out their colors and mileage. Your expected output are below:\n\n\n\n::: {#0026b5d3 .cell execution_count=32}\n``` {.python .cell-code}\ncar1 = mycar(color='blue', mileage=20000)\ncar2 = mycar(color='red', mileage=30000)\n\nprint(car1)\nprint(car2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA blue car with 20000 mileage.\nA red car with 30000 mileage.\n```\n:::\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nCreate a `GoldenRetriever` class that inherits from the `Dog` class. Give the `sound` argument of `GoldenRetriever.speak()` a default value of `Bark`. Use the following code for your parent `Dog` class:\n\n::: {#3a6685be .cell execution_count=33}\n``` {.python .cell-code}\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    def speak(self, sound):\n        return f\"{self.name} says {sound}\"\n```\n:::\n\n\n:::\n\n",
    "supporting": [
      "intro_files"
    ],
    "filters": [],
    "includes": {}
  }
}